{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>\u76ee\u6307\u305b Library Checker \u5168\u5b8c</p>"},{"location":"#sample","title":"Sample","text":"Title Status Submission A + B link Many A + B link Many A + B (128 bit)"},{"location":"#data-structure","title":"Data Structure","text":"Title Status Submission Associative Array link Predecessor Problem Double-Ended Priority Queue Unionfind link Static Range Sum link Static RMQ link Point Add Range Sum link Point Set Range Composite link Range Affine Point Get Range Affine Range Sum link Range Set Range Composite Range Chmin Chmax Add Range Sum link Range Kth Smallest link Point Set Range Sort Range Composite Range Reverse Range Sum Vertex Add Path Sum link Vertex Set Path Composite link Vertex Add Subtree Sum link Vertex Add Range Contour Sum on Tree Vertex Get Range Contour Add on Tree Dynamic Sequence Range Affine Range Sum Dynamic Tree Vertex Add Path Sum Dynamic Tree Vertex Set Path Composite Dynamic Tree Vertex Add Subtree Sum Dynamic Tree Subtree Add Subtree Sum Dynamic Graph Vertex Add Component Sum Set Xor-Min Line Add Get Min Segment Add Get Min Queue Operate All Composite Deque Operate All Composite Static Range Frequency Static Range Count Distinct Static Range Mode Query Static Range LIS Query Static Range Inversions Query Rectangle Sum Point Add Rectangle Sum Rectangle Add Point Get Static Rectangle Add Rectangle Sum Area of Union of Rectangles Persistent Queue Persistent Unionfind"},{"location":"#graph","title":"Graph","text":"Title Status Submission Cycle Detection (Directed) Cycle Detection (Undirected) Shortest Path Strongly Connected Components K-Shortest Walk Two-Edge-Connected Components Three-Edge-Connected Components Biconnected Components Eulerian Trail (Directed) Eulerian Trail (Undirected) Minimum Cost b-flow Matching on Bipartite Graph Matching on General Graph General Weighted Matching Edge Coloring of Bipartite Graph Assignment Problem Minimum Spanning Tree Directed MST Manhattan MST Dominator Tree Maximum Independent Set Chromatic Number Enumerate Triangles Enumerate Cliques Tree Decomposition (Width 2) Global Minimum Cut of Dynamic Star Augmented Graph Chordal Graph Recognition"},{"location":"#tree","title":"Tree","text":"Title Status Submission Tree Diameter Lowest Common Ancestor Jump on Tree Cartesian Tree Common Interval Decomposition Tree Frequency Table of Tree Distance Rooted Tree Isomorphism Classification Tree Path Composite Sum"},{"location":"#math","title":"Math","text":"Title Status Submission Enumerate Quotients Primality Test Counting Primes Enumerate Primes Factorize Primitive Root Factorial Many Factorials Binomial Coefficient Binomial Coefficient (Prime Mod) Stirling Number of the First Kind Stirling Number of the First Kind (Fixed K) Stirling Number of the Second Kind Stirling Number of the Second Kind (Fixed K) Stirling Number of the First Kind (Small p, Large n) Stirling Number of the Second Kind (Small p, Large n) Bernoulli Number Partition Function Montmort Number Counting Square-free Integers Sum of Totient Function \\(\\sum_{i=0}^{n-1} r^ii^d\\) \\(\\sum_{i=0}^{\\infty} r^ii^d\\) Find Linear Recurrence Kth term of Linearly Recurrent Sequence Consecutive Terms of Linear Recurrent Sequence Sum of Floor of Linear Min of Mod of Linear Sqrt Mod Kth Root (Mod) Kth Root (Integer) Discrete Logarithm Tetration Mod Nim Product (\\(\\mathbb{F}_{2^{64}}\\)) \\(\\#_p\\) Subset Sum 2 Sat Longest Increasing Subsequence Number of Subsequences Addition of Big Integers Multiplication of Big Integers Division of Big Integers Stern-Brocot Tree Polynomial Composite Set Power Series Exp of Set Power Series Gcd of Gaussian Integers"},{"location":"#convolution","title":"Convolution","text":"Title Status Submission Convolution Convolution (Mod 1,000,000,007) Convolution (Mod 2^64) Convolution (Large) Subset Convolution Bitwise And Convolution Bitwise Xor Convolution Gcd Convolution Lcm Convolution Multidimensional Convolution (Truncated) Multidimensional Convolution (Circular) Convolution on the Multiplicative Monoid of \\(\\mathbb{Z}/P\\mathbb{Z}\\) Convolution on the Multiplicative Monoid of \\(\\mathbb{Z}/2^N\\mathbb{Z}\\) Min Plus Convolution (Convex and Arbitrary) Min Plus Convolution (Convex and Convex)"},{"location":"#polynomial","title":"Polynomial","text":"Title Status Submission Inv of Formal Power Series Exp of Formal Power Series Log of Formal Power Series Pow of Formal Power Series Sqrt of Formal Power Series Composition of Formal Power Series Compositional Inverse of Formal Power Series Inv of Formal Power Series (Sparse) Exp of Formal Power Series (Sparse) Log of Formal Power Series (Sparse) Pow of Formal Power Series (Sparse) Sqrt of Formal Power Series (Sparse) Product of Polynomial Sequence Multipoint Evaluation Multipoint Evaluation (Geometric Sequence) Polynomial Interpolation Polynomial Interpolation (Geometric Sequence) Polynomial Taylor Shift Shift of Sampling Points of Polynomial Division of Polynomials Inv of Polynomials Conversion from Monomial Basis to Newton Basis Polynomial Root Finding (Mod 998244353)"},{"location":"#matrix","title":"Matrix","text":"Title Status Submission Matrix Product Pow of Matrix Determinant of Matrix Determinant of Matrix (Arbitrary Mod) Determinant of Sparse Matrix Rank of Matrix System of Linear Equations Inverse Matrix Characteristic Polynomial Hafnian of Matrix"},{"location":"#string","title":"String","text":"Title Status Submission Z Algorithm link Enumerate Palindromes link Suffix Array Number of Substrings Run Enumerate Prefix-Substring LCS Lyndon Factorization Longest Common Substring"},{"location":"#geometry","title":"Geometry","text":"Title Status Submission Sort Points by Argument link Count Points in Triangles Convex Layers"},{"location":"bit/LSB/","title":"LSB","text":""},{"location":"bit/LSB/#c","title":"C++","text":"<p><pre><code>int LSB(int n){\n    return n &amp; -n;\n}\n</code></pre> <pre><code>long long LSB(long long n){\n    return n &amp; -n;\n}\n</code></pre></p>"},{"location":"bit/MSB/","title":"MSB","text":""},{"location":"bit/MSB/#c","title":"C++","text":"<p><pre><code>int MSB(int n) {\n    n |= (n &gt;&gt; 1);\n    n |= (n &gt;&gt; 2);\n    n |= (n &gt;&gt; 4);\n    n |= (n &gt;&gt; 8);\n    n |= (n &gt;&gt; 16);\n    return n - (n &gt;&gt; 1);\n}\n</code></pre> <pre><code>long long MSB(long long n) {\n    n |= (n &gt;&gt; 1);\n    n |= (n &gt;&gt; 2);\n    n |= (n &gt;&gt; 4);\n    n |= (n &gt;&gt; 8);\n    n |= (n &gt;&gt; 16);\n    n |= (n &gt;&gt; 32);\n    return n - (n &gt;&gt; 1);\n}\n</code></pre></p>"},{"location":"data_structure/2d_segment_tree/","title":"2d segment tree","text":""},{"location":"data_structure/2d_segment_tree/#c","title":"c++","text":"<pre><code>template&lt;class S, S (*op)(S, S), S (*e)()&gt;\nstruct SegmentTree2D{\n    public:\n        int H, W, szH, szW;\n        vector&lt;vector&lt;S&gt;&gt; val;\n\n        SegmentTree2D(): SegmentTree2D(0, 0) {}\n        SegmentTree2D(int H, int W): SegmentTree2D(vector&lt;vector&lt;S&gt;&gt;(H, vector(W, e()))) {}\n        SegmentTree2D(const vector&lt;vector&lt;S&gt;&gt;&amp; v): H(v.size()), W(v.empty() ? 0 : v[0].size()) {\n            szH = 1, szW = 1;\n            while(szH &lt; H) szH &lt;&lt;= 1;\n            while(szW &lt; W) szW &lt;&lt;= 1;\n\n            val.resize(szH&lt;&lt;1, vector&lt;S&gt;(szW&lt;&lt;1, e()));\n            for(int i=0; i&lt;H; i++)for(int j=0; j&lt;W; j++) val[szH + i][szW + j] = v[i][j];\n            for(int i=(szH&lt;&lt;1)-1; i&gt;0; i--)for(int j=(szW&lt;&lt;1)-1; j&gt;0; j--) update(i, j);\n        }\n\n        void set(int x, int y, S v){\n            assert(0 &lt;= x and x&lt;H and 0 &lt;= y and y&lt;W);\n\n            x += szH, y += szW;\n            val[x][y] = v;\n\n            for(int i=x; i&gt;1; i&gt;&gt;=1)for(int j=y; j&gt;1; j&gt;&gt;=1){\n                if(i==x and j==y) continue;\n                update(i, j);\n            }\n        }\n\n        S get(int i, int j){\n            assert(0 &lt;= i and i&lt;H and 0 &lt;= j and j&lt;W);\n\n            i += szH, j += szW;\n            return val[i][j];\n        }\n\n        S prod(int lh, int rh, int lw, int rw){\n            lh += szH, rh += szH, lw += szW, rw += szW;\n            S vlh = e(), vrh = e();\n\n            while(lh &lt; rh){\n                if(lh &amp; 1){\n                    S vlw = e(), vrw = e();\n                    int tmp_lw = lw, tmp_rw = rw;\n                    while(tmp_lw &lt; tmp_rw){\n                        if(tmp_lw &amp; 1) vlw = op(vlw, val[lh][tmp_lw++]);\n                        if(tmp_rw &amp; 1) vrw = op(val[lh][--tmp_rw], vrw);\n                        tmp_lw &gt;&gt;= 1;\n                        tmp_rw &gt;&gt;= 1;\n                    }\n                    vlh = op(vlh, op(vlw, vrw));\n                    lh++;\n                }\n                if(rh &amp; 1){\n                    --rh;\n                    S vlw = e(), vrw = e();\n                    int tmp_lw = lw, tmp_rw = rw;\n                    while(tmp_lw &lt; tmp_rw){\n                        if(tmp_lw &amp; 1) vlw = op(vlw, val[rh][tmp_lw++]);\n                        if(tmp_rw &amp; 1) vrw = op(val[rh][--tmp_rw], vrw);\n                        tmp_lw &gt;&gt;= 1;\n                        tmp_rw &gt;&gt;= 1;\n                    }\n                    vrh = op(op(vlw, vrw), vrh);\n                }\n                lh &gt;&gt;= 1;\n                rh &gt;&gt;= 1;\n            }\n\n            return op(vlh, vrh);\n        }\n\n    private:\n        void update(int i, int j){\n            if(szH &lt;= i and szW &lt;= j) return;\n            S v1 = op(_get(i, 2*j), _get(i, 2*j+1));\n            S v2 = op(_get(2*i, j), _get(2*i+1, j));\n            val[i][j] = op(v1, v2);\n        }\n\n        S _get(int i, int j){\n            if(i &gt;= 2*szH or j &gt;= 2*szW) return e();\n            return val[i][j];\n        }\n};\n</code></pre>"},{"location":"data_structure/binary_indexed_tree/","title":"Binary indexed tree","text":""},{"location":"data_structure/binary_indexed_tree/#c","title":"c++","text":"<pre><code>template&lt;typename T&gt;\nstruct BIT{\n    private:\n        using Func = function&lt;T(T, T)&gt;;\n\n        int n;\n        vector&lt;T&gt; node;\n\n        T init_v;\n        Func func;\n\n    public:\n\n        BIT(int N, Func _func, T _init_v) {\n            n = N + 1;\n            init_v = _init_v;\n            func = _func;\n\n            node.resize(n, init_v);\n            for(int i=1; i&lt;n; i++) if((i+(i&amp;-i)) &lt; n) node[i+(i&amp;-i)] = func(node[i+(i&amp;-i)], node[i]);\n        }\n\n        BIT() {}\n\n        void add(int pos, T v) {\n            // 0-indexed\n            pos++;\n            while(pos &lt; n){\n                node[pos] = func(node[pos], v);\n                pos += pos &amp; -pos;\n            }\n        }\n\n        T sum(int pos){\n            // 0-indexed\n            // [0,pos]\u306e\u7dcf\u548c\n            pos++;\n            T res = init_v;\n            while(pos &gt; 0){\n                res = func(res, node[pos]);\n                pos = pos &amp; (pos-1);\n            }\n            return res;\n        }\n\n        T sum(int l, int r){\n            // 0-indexed\n            // [l,r)\u306e\u7dcf\u548c\n            return sum(r-1) - sum(l-1);\n        }\n};\n</code></pre>"},{"location":"data_structure/binary_trie/","title":"Binary trie","text":""},{"location":"data_structure/binary_trie/#c","title":"c++","text":"<pre><code>template&lt;class T, int bit=30&gt;\nstruct BinaryTrie {\n    vector&lt;pair&lt;int,int&gt;&gt; dat;\n\n    BinaryTrie(): BinaryTrie(vector&lt;T&gt;{}) {}\n    BinaryTrie(const vector&lt;T&gt; v){\n        dat.emplace_back(-1, -1);\n\n        for(T x : v) insert(x);\n    }\n\n    void insert(T x){\n        int pos = 0;\n        for(int i=bit-1; i&gt;=0; i--){\n            int b = 1 &amp; (x&gt;&gt;i);\n            if(b){\n                if(dat[pos].second == -1){\n                    dat[pos].second = dat.size();\n                    dat.emplace_back(-1,-1);\n                }\n                pos = dat[pos].second;\n            }\n            else{\n                if(dat[pos].first == -1){\n                    dat[pos].first = dat.size();\n                    dat.emplace_back(-1,-1);\n                }\n                pos = dat[pos].first;\n            }\n        }\n    }\n\n    bool exist(T x){\n        int pos = 0;\n        for(int i=bit-1; i&gt;=0; i--){\n            int b = 1 &amp; (x&gt;&gt;i);\n            if(b){\n                if(dat[pos].second == -1) return false;\n                pos = dat[pos].second;\n            }\n            else{\n                if(dat[pos].first == -1) return false;\n                pos = dat[pos].first;\n            }\n        }\n        return true;\n    }\n\n    T min_xor(T x){\n        if(dat.size() == 1) return -1;\n        int pos = 0, ret = 0;\n        for(int i=bit-1; i&gt;=0; i--){\n            int b = 1 &amp; (x&gt;&gt;i);\n            if(b){\n                if(dat[pos].second == -1){\n                    ret |= 1LL&lt;&lt;i;\n                    pos = dat[pos].first;\n                }\n                else{\n                    pos = dat[pos].second;\n                }\n            }\n            else{\n                if(dat[pos].first == -1){\n                    ret |= 1LL&lt;&lt;i;\n                    pos = dat[pos].second;\n                }\n                else{\n                    pos = dat[pos].first;\n                }\n            }\n        }\n        return ret;\n    }\n};\n</code></pre>"},{"location":"data_structure/bit_array/","title":"Bit array","text":""},{"location":"data_structure/bit_array/#c","title":"c++","text":"<pre><code>struct BitArray{\n    uint64_t n;\n    static const uint64_t b = 64;\n    static const uint64_t l = 512;\n    static const uint64_t s = 64;\n    static const uint64_t MASK = (1LLU&lt;&lt;63)-1 + (1LLU&lt;&lt;63);\n\n    vector&lt;uint64_t&gt; B;\n    vector&lt;uint64_t&gt; L, S;\n\n    BitArray() {}\n    BitArray(vector&lt;bool&gt;&amp; a){\n        uint64_t sz = a.size();\n        uint64_t szB,szL,szS;\n        szB = (sz + b-1) / b;\n        szL = (sz + l-1) / l;\n        szS = l/s*szL;\n\n        B.assign(szB,0);\n        L.assign(szL,0);\n        S.assign(szS,0);\n\n        for(uint64_t i=0; i&lt;sz; ++i){\n            if(!a[i]) continue;\n            uint64_t bpos = i/b, offset = b - i%b - 1;\n            B[bpos] |= 1LLU&lt;&lt;offset;\n        }\n\n        for(uint64_t i=0; i&lt;(szL-1)*l; ++i){\n            uint64_t lpos = i/l+1;\n            L[lpos] += a[i];\n        }\n\n        uint64_t num = 0;\n        for(uint64_t i=0; i&lt;szS*s; ++i){\n            if(i%s == 0){\n                uint64_t spos = i/s, lpos = i/l;\n                S[spos] = num - L[lpos];\n            }\n            if(i&lt;sz) num += a[i];\n        }\n    }\n\n    uint64_t pop_count(uint64_t x) {\n        x = (x &amp; 0x5555555555555555ULL) + ((x &gt;&gt; 1) &amp; 0x5555555555555555ULL);\n        x = (x &amp; 0x3333333333333333ULL) + ((x &gt;&gt; 2) &amp; 0x3333333333333333ULL);\n        x = (x + (x &gt;&gt; 4)) &amp; 0x0f0f0f0f0f0f0f0fULL;\n        x = x + (x &gt;&gt;  8);\n        x = x + (x &gt;&gt; 16);\n        x = x + (x &gt;&gt; 32);\n        return x &amp; 0x7FLLU;\n    }\n\n    uint64_t access(int pos){\n        int bpos = pos/b, bit = b-1-pos%b;\n        uint64_t ret = (B[bpos]&gt;&gt;bit) &amp; 1;\n        return ret;\n    }\n\n    uint64_t rank(int pos, int bit){\n        int bpos = pos/b, lpos = pos/l, spos = pos/s;\n        int nbit = b-pos%b -1;\n        uint64_t mask = MASK - ((1LLU&lt;&lt;nbit)-1 + (1LLU&lt;&lt;nbit));\n        uint64_t n = L[lpos] + S[spos] + pop_count(B[bpos] &amp; mask);\n        uint64_t ret = bit ? n : pos-n;\n        return ret;\n    }\n\n    uint64_t select(int n, int bit){\n\n        // L\u5185\u3067\u4e8c\u5206\u63a2\u7d22\n        int ok=0, ng=L.size();\n        while(ng-ok&gt;1){\n            int pos = (ok+ng)/2;\n            int k = bit ? L[pos] : l*pos - L[pos];\n            if(k &lt; n) ok = pos;\n            else ng = pos;\n        }\n        int lpos = ok;\n\n        // S\u5185\u3067\u4e8c\u5206\u63a2\u7d22\n        ok=l*lpos/s, ng=ok+l/s;\n        while(ng-ok&gt;1){\n            int pos = (ok+ng)/2;\n            int k = bit ? L[lpos]+S[pos] : l*lpos+s*pos - (L[lpos]+S[pos]);\n            if(k &lt; n) ok = pos;\n            else ng = pos;\n        }\n        int spos = ok;\n\n        // B\u5185\u3067\u4e8c\u5206\u63a2\u7d22\n        int bpos = s*spos/b;\n        int tmp = bit ? L[lpos]+S[spos] : l*lpos+s*spos - (L[lpos]+S[spos]);\n        ok=0, ng=b;\n        while(ng-ok&gt;1){\n            int nbit = (ok+ng)/2;\n            uint64_t mask = MASK - (1LLU&lt;&lt;nbit) + 1;\n            int k = tmp + (bit ? pop_count(B[bpos] &amp; mask) : b-pop_count(B[bpos] &amp; mask)-nbit);\n            if(k &lt; n) ng = nbit;\n            else ok = nbit;\n        }\n        int nbit = b-ok;\n\n        uint64_t ret = l*lpos + s*spos + nbit;\n        return ret;\n    }\n};\n</code></pre>"},{"location":"data_structure/convex_hull_trick/","title":"Convex hull trick","text":""},{"location":"data_structure/convex_hull_trick/#c","title":"c++","text":"<pre><code>template&lt;bool maximize=false&gt;\nstruct ConvexHullTrick {\n    using ll = long long;\n    map&lt;ll,ll&gt; mp;\n\n    void insert(ll a, ll b){\n        if(maximize) a = -a, b = -b;\n\n        if(mp.empty()){\n            mp[a] = b;\n            return;\n        }\n        else if(mp.size() == 1){\n            if(mp.count(a)) chmin(mp[a], b);\n            else mp[a] = b;\n            return;\n        }\n\n        bool add = false;\n\n        // \u7aef\n        if(a &lt; (*mp.begin()).first or (*mp.rbegin()).first &lt; a){\n            mp[a] = b;\n            add = true;\n        }\n        // \u540c\u3058\u50be\u304d\u304c\u5b58\u5728\n        else if(mp.count(a)){\n            if(chmin(mp[a], b)) add = true;\n        }\n        else{\n            pair&lt;ll,ll&gt; l = *mp.upper_bound(a), r = *mp.lower_bound(a);\n\n            if(_judge(l, {a,b}, r)){\n                mp[a] = b;\n                add = true;\n            }\n        }\n\n        if(add) remove(a);\n        return;\n    }\n\n    void remove(ll a){\n        // +\n        {\n            auto it = mp.lower_bound(a); ++it;\n\n            while((*it).first != (*mp.rbegin()).first){\n                --it;\n                pair&lt;ll,ll&gt; l = *it;\n                ++it;\n                pair&lt;ll,ll&gt; m = *it;\n                ++it;\n                pair&lt;ll,ll&gt; r = *it;\n\n                if(_judge(l,m,r)) break;\n\n                mp.erase(m.first);\n            }\n        }\n        // -\n        {\n            auto it = mp.upper_bound(a);\n            while((*it).first != (*mp.begin()).first){\n                ++it;\n                pair&lt;ll,ll&gt; r = *it;\n                --it;\n                pair&lt;ll,ll&gt; m = *it;\n                --it;\n                pair&lt;ll,ll&gt; l = *it;\n\n                if(_judge(l,m,r)) break;\n\n                mp.erase(m.first);\n            }\n        }\n        return;\n    }\n\n    bool _judge(pair&lt;ll,ll&gt; l, pair&lt;ll,ll&gt; m, pair&lt;ll,ll&gt; r){\n        // m\u304c\u5fc5\u8981 -&gt; true\n        ll a,b,al,bl,ar,br;\n        tie(al,bl) = l; tie(a,b) = m; tie(ar,br) = r;\n\n        return (a-al)*(br-bl) &gt; (ar-al)*(b-bl);\n    }\n\n    ll query(ll x){\n        if(mp.size() == 1){\n            auto it = *mp.begin();\n            ll a,b; tie(a,b) = it;\n            return a*x + b;\n        }\n\n        auto itl = mp.begin(), itr = prev(mp.end());\n\n        auto check = [&amp;](){\n            if(itl == itr) return false;\n            itl++;\n            ll p = (*itl).first, q = (*itr).first;\n            itl--;\n            return p != q;\n        };\n\n        while(check()){\n            ll al,bl,ar,br; tie(al,bl) = *itl; tie(ar,br) = *itr;\n            ll m = (al+ar)/2;\n            auto it1 = mp.upper_bound(m);\n            auto it0 = prev(it1);\n\n            ll a0,b0,a1,b1; tie(a0,b0) = *it0; tie(a1,b1) = *it1;\n            if(a0*x+b0 &lt; a1*x+b1) itr = it0;\n            else itl = it1;\n        }\n\n        ll al,bl,ar,br; tie(al,bl) = *itl; tie(ar,br) = *itr;\n        ll ret = min(al*x+bl, ar*x+br);\n        return ret;\n    }\n};\n</code></pre>"},{"location":"data_structure/fenwick_tree/","title":"Fenwick tree","text":""},{"location":"data_structure/fenwick_tree/#c","title":"C++","text":"<pre><code>template &lt;class T = int&gt; struct FenwickTree {\n  public:\n    FenwickTree() : _n(0) {}\n    explicit FenwickTree(int n) : _n(n), data(n) {}\n\n    void add(int p, T x) {\n        p++;\n        while (p &lt;= _n) {\n            data[p - 1] += x;\n            p += p &amp; -p;\n        }\n    }\n\n    T sum(int l, int r) {\n        return sum(r) - sum(l);\n    }\n\n  private:\n    int _n;\n    std::vector&lt;T&gt; data;\n\n    T sum(int r) {\n        T s = 0;\n        while (r &gt; 0) {\n            s += data[r - 1];\n            r -= r &amp; -r;\n        }\n        return s;\n    }\n};\n</code></pre>"},{"location":"data_structure/heavy_light_decomposition/","title":"Heavy light decomposition","text":""},{"location":"data_structure/heavy_light_decomposition/#c","title":"c++","text":"<pre><code>struct HeavyLightDecomposition {\n    int n,pos;\n    vector&lt;vector&lt;int&gt;&gt; edge;\n    vector&lt;int&gt; vid, head, sub, hvy, par, dep, inv, type;\n\n    HeavyLightDecomposition(){}\n    HeavyLightDecomposition(int sz):\n        n(sz),pos(0),edge(n),\n        vid(n,-1),head(n),sub(n,1),hvy(n,-1),\n        par(n),dep(n),inv(n),type(n) {}\n\n    void add_edge(int u, int v){\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n    }\n\n    void build(int r=0){\n        int c = 0;\n        dfs(r);\n        bfs(r, c++);\n    }\n\n    void dfs(int rt){\n        stack&lt;pair&lt;int,int&gt;&gt; stk;\n        par[rt] = -1; dep[rt] = 0;\n        stk.emplace(rt,0);\n        while(!stk.empty()){\n            int v = stk.top().first;\n            int &amp;i = stk.top().second;\n            if(i &lt; (int)edge[v].size()){\n                int u = edge[v][i++];\n                if(u == par[v]) continue;\n                par[u] = v;\n                dep[u] = dep[v]+1;\n                stk.emplace(u,0);\n            }\n            else{\n                stk.pop();\n                int res = 0;\n                for(int u : edge[v]){\n                    if(u == par[v]) continue;\n                    sub[v] += sub[u];\n                    if(res&lt;sub[u]) res = sub[u], hvy[v] = u;\n                }\n            }\n        }\n    }\n\n    void bfs(int r, int c){\n        int &amp;k = pos;\n        queue&lt;int&gt; que({r});\n        while(!que.empty()){\n            int h=que.front();que.pop();\n            for(int i=h;i!=-1;i=hvy[i]){\n                type[i] = c;\n                vid[i] = k++;\n                inv[vid[i]] = i;\n                head[i] = h;\n                for(int j : edge[i]){\n                    if(j==par[i] || j==hvy[i]) continue;\n                    que.push(j);\n                }\n            }\n        }\n    }\n\n    // for_each(vertex)\n    // [l,r] &lt;- attention!!\n    void for_each(int u, int v, const function&lt;void(int, int)&gt;&amp; f){\n        while(true){\n            if(vid[u] &gt; vid[v]) swap(u,v);\n            f(max(vid[head[v]],vid[u]), vid[v]);\n            if(head[u] != head[v]) v = par[head[v]];\n            else break;\n        }\n    }\n\n    // for_each(edge)\n    // [l,r] &lt;- attention!!\n    void for_each_edge(int u, int v, const function&lt;void(int, int)&gt;&amp; f){\n        while(true){\n            if(vid[u] &gt; vid[v]) swap(u,v);\n            if(head[u] != head[v]){\n                f(vid[head[v]], vid[v]);\n                v = par[head[v]];\n            }\n            else{\n                if(u!=v) f(vid[u]+1, vid[v]);\n                break;\n            }\n        }\n    }\n\n    int lca(int u, int v){\n        while(true){\n            if(vid[u] &gt; vid[v]) swap(u,v);\n            if(head[u] == head[v]) return u;\n            v = par[head[v]];\n        }\n    }\n\n    int distance(int u, int v){\n        return dep[u] + dep[v] - 2*dep[lca(u,v)];\n    }\n};\n</code></pre>"},{"location":"data_structure/lazy_segment_tree/","title":"Lazy segment tree","text":""},{"location":"data_structure/lazy_segment_tree/#c","title":"c++","text":"<pre><code>template &lt;class S,\n          S (*op)(S, S),\n          S (*e)(),\n          class F,\n          S (*mapping)(F, S),\n          F (*composition)(F, F),\n          F (*id)()&gt;\nstruct LazySegmentTree {\n  public:\n    LazySegmentTree() : LazySegmentTree(0) {}\n    LazySegmentTree(int n) : LazySegmentTree(std::vector&lt;S&gt;(n, e())) {}\n    LazySegmentTree(const std::vector&lt;S&gt;&amp; v) : _n(int(v.size())) {\n        log = ceil_pow2(_n);\n        size = 1 &lt;&lt; log;\n        d = std::vector&lt;S&gt;(2 * size, e());\n        lz = std::vector&lt;F&gt;(size, id());\n        for (int i = 0; i &lt; _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i &gt;= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 &lt;= p &amp;&amp; p &lt; _n);\n        p += size;\n        for (int i = log; i &gt;= 1; i--) push(p &gt;&gt; i);\n        d[p] = x;\n        for (int i = 1; i &lt;= log; i++) update(p &gt;&gt; i);\n    }\n\n    S get(int p) {\n        assert(0 &lt;= p &amp;&amp; p &lt; _n);\n        p += size;\n        for (int i = log; i &gt;= 1; i--) push(p &gt;&gt; i);\n        return d[p];\n    }\n\n    S prod(int l, int r) {\n        assert(0 &lt;= l &amp;&amp; r &lt;= _n);\n        if (l &gt;= r) return e();\n\n        l += size;\n        r += size;\n\n        for (int i = log; i &gt;= 1; i--) {\n            if (((l &gt;&gt; i) &lt;&lt; i) != l) push(l &gt;&gt; i);\n            if (((r &gt;&gt; i) &lt;&lt; i) != r) push(r &gt;&gt; i);\n        }\n\n        S sml = e(), smr = e();\n        while (l &lt; r) {\n            if (l &amp; 1) sml = op(sml, d[l++]);\n            if (r &amp; 1) smr = op(d[--r], smr);\n            l &gt;&gt;= 1;\n            r &gt;&gt;= 1;\n        }\n\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    void apply(int p, F f) {\n        assert(0 &lt;= p &amp;&amp; p &lt; _n);\n        p += size;\n        for (int i = log; i &gt;= 1; i--) push(p &gt;&gt; i);\n        d[p] = mapping(f, d[p]);\n        for (int i = 1; i &lt;= log; i++) update(p &gt;&gt; i);\n    }\n    void apply(int l, int r, F f) {\n        assert(0 &lt;= l &amp;&amp; l &lt;= r &amp;&amp; r &lt;= _n);\n        if (l == r) return;\n\n        l += size;\n        r += size;\n\n        for (int i = log; i &gt;= 1; i--) {\n            if (((l &gt;&gt; i) &lt;&lt; i) != l) push(l &gt;&gt; i);\n            if (((r &gt;&gt; i) &lt;&lt; i) != r) push((r - 1) &gt;&gt; i);\n        }\n\n        {\n            int l2 = l, r2 = r;\n            while (l &lt; r) {\n                if (l &amp; 1) all_apply(l++, f);\n                if (r &amp; 1) all_apply(--r, f);\n                l &gt;&gt;= 1;\n                r &gt;&gt;= 1;\n            }\n            l = l2;\n            r = r2;\n        }\n\n        for (int i = 1; i &lt;= log; i++) {\n            if (((l &gt;&gt; i) &lt;&lt; i) != l) update(l &gt;&gt; i);\n            if (((r &gt;&gt; i) &lt;&lt; i) != r) update((r - 1) &gt;&gt; i);\n        }\n    }\n\n    template &lt;class G&gt; int max_right(int l, G g) {\n        assert(0 &lt;= l &amp;&amp; l &lt;= _n);\n        assert(g(e()));\n        if (l == _n) return _n;\n        l += size;\n        for (int i = log; i &gt;= 1; i--) push(l &gt;&gt; i);\n        S sm = e();\n        do {\n            while (l % 2 == 0) l &gt;&gt;= 1;\n            if (!g(op(sm, d[l]))) {\n                while (l &lt; size) {\n                    push(l);\n                    l = (2 * l);\n                    if (g(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l &amp; -l) != l);\n        return _n;\n    }\n\n    template &lt;class G&gt; int min_left(int r, G g) {\n        assert(0 &lt;= r &amp;&amp; r &lt;= _n);\n        assert(g(e()));\n        if (r == 0) return 0;\n        r += size;\n        for (int i = log; i &gt;= 1; i--) push((r - 1) &gt;&gt; i);\n        S sm = e();\n        do {\n            r--;\n            while (r &gt; 1 &amp;&amp; (r % 2)) r &gt;&gt;= 1;\n            if (!g(op(d[r], sm))) {\n                while (r &lt; size) {\n                    push(r);\n                    r = (2 * r + 1);\n                    if (g(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r &amp; -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector&lt;S&gt; d;\n    std::vector&lt;F&gt; lz;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    void all_apply(int k, F f) {\n        d[k] = mapping(f, d[k]);\n        if (k &lt; size) lz[k] = composition(f, lz[k]);\n    }\n    void push(int k) {\n        all_apply(2 * k, lz[k]);\n        all_apply(2 * k + 1, lz[k]);\n        lz[k] = id();\n    }\n    int ceil_pow2(int n) {\n        int x = 0;\n        while ((1U &lt;&lt; x) &lt; (unsigned int)(n)) x++;\n        return x;\n    }\n};\n</code></pre>"},{"location":"data_structure/mo_algorithm/","title":"Mo algorithm","text":""},{"location":"data_structure/mo_algorithm/#c","title":"C++","text":"<pre><code>template &lt;class T&gt;\nstruct Problem {\n    Problem() {\n    }\n\n    void add_id(int i) {\n        // process for adding index i\n    }\n    void erase_id(int i) {\n        // process for erasing index i\n    }\n    T get_answer() {\n        // return current answer\n    }\n};\n\nstruct Segment {\n    int L, R, query_id, block_id;\n    Segment(int L, int R, int query_id, int block_id) : L(L), R(R), query_id(query_id), block_id(block_id) {}\n\n    std::tuple&lt;int, int, int&gt; get_key() const {\n        if (block_id &amp; 1) {\n            return std::make_tuple(block_id, -R, L);\n        }\n        return std::make_tuple(block_id, R, L);\n    }\n};\n\nbool operator&lt;(const Segment &amp;lhs, const Segment &amp;rhs) {\n    return lhs.get_key() &lt; rhs.get_key();\n}\n\ntemplate &lt;class T&gt;\nstruct Mo {\n    int N, Q, sqrt_Q;\n    std::vector&lt;int&gt; L, R;\n\n    Mo(int N, int Q, std::vector&lt;int&gt; L, std::vector&lt;int&gt; R) : N(N), Q(Q), L(L), R(R) {\n        this-&gt;sqrt_Q = calc_sqrt(Q);\n    }\n\n    std::vector&lt;Segment&gt; get_sorted_segments() {\n        std::vector&lt;Segment&gt; segments;\n        for (int i = 0; i &lt; Q; i++) {\n            segments.push_back(Segment(L[i], R[i], i, L[i] / sqrt_Q));\n        }\n        std::sort(segments.begin(), segments.end());\n        return segments;\n    }\n\n    std::vector&lt;T&gt; solve(Problem&lt;T&gt; p) {\n        int l = 0, r = 0;\n        std::vector&lt;Segment&gt; segments = get_sorted_segments();\n        std::vector&lt;T&gt; answers(Q);\n\n        for (Segment &amp;segment : segments) {\n            int l_next = segment.L, r_next = segment.R;\n\n            if (r &lt; r_next) {\n                for (int i = r; i &lt; r_next; i++) {\n                    p.add_id(i);\n                }\n\n                if (l &lt; l_next) {\n                    for (int i = l; i &lt; l_next; i++) {\n                        p.erase_id(i);\n                    }\n                } else {\n                    for (int i = l - 1; i &gt;= l_next; i--) {\n                        p.add_id(i);\n                    }\n                }\n            } else {\n                if (l &lt; l_next) {\n                    for (int i = l; i &lt; l_next; i++) {\n                        p.erase_id(i);\n                    }\n                } else {\n                    for (int i = l - 1; i &gt;= l_next; i--) {\n                        p.add_id(i);\n                    }\n                }\n\n                for (int i = r - 1; i &gt;= r_next; i--) {\n                    p.erase_id(i);\n                }\n            }\n\n            answers[segment.query_id] = p.get_answer();\n            l = l_next;\n            r = r_next;\n        }\n\n        return answers;\n    }\n\n  private:\n    int calc_sqrt(int x) {\n        int ng = 0, ok = sqrt(x) + 2;\n        while (ok - ng &gt; 1) {\n            int m = (ok + ng) / 2;\n            if (m * m &lt; x)\n                ng = m;\n            else\n                ok = m;\n        }\n        return ok;\n    }\n};\n</code></pre>"},{"location":"data_structure/mo_algorithm/#rust","title":"Rust","text":"<pre><code>pub mod mo {\n    use itertools::Itertools;\n    use num_integer::Roots;\n\n    pub trait Problem&lt;T: Copy&gt; {\n        fn add_id(&amp;mut self, i: usize);\n        fn erase_id(&amp;mut self, i: usize);\n        fn answer(&amp;mut self) -&gt; T;\n    }\n\n    #[derive(Clone, Copy)]\n    struct Segment {\n        l: usize,\n        r: usize,\n        query_id: usize,\n        block_id: usize,\n    }\n\n    pub struct Mo {\n        n: usize,\n        q: usize,\n        l: Vec&lt;usize&gt;,\n        r: Vec&lt;usize&gt;,\n        sqrt_q: usize,\n    }\n\n    impl Mo {\n        pub fn new(n: usize, q: usize, l: Vec&lt;usize&gt;, r: Vec&lt;usize&gt;) -&gt; Self {\n            let sqrt_q = q.sqrt();\n            Self { n, q, l, r, sqrt_q }\n        }\n\n        fn get_sorted_segment(&amp;self) -&gt; Vec&lt;Segment&gt; {\n            let mut segments = self\n                .l\n                .iter()\n                .zip(self.r.iter())\n                .enumerate()\n                .map(|(i, (&amp;l, &amp;r))| Segment {\n                    l,\n                    r,\n                    query_id: i,\n                    block_id: l / self.sqrt_q,\n                })\n                .collect_vec();\n\n            segments.sort_by_key(|segment| {\n                if (segment.block_id &amp; 1) == 1 {\n                    (segment.block_id, self.n - segment.r)\n                } else {\n                    (segment.block_id, segment.r)\n                }\n            });\n\n            segments\n        }\n\n        pub fn solve&lt;T: Copy&gt;(&amp;mut self, p: &amp;mut impl Problem&lt;T&gt;) -&gt; Vec&lt;T&gt; {\n            let (mut l, mut r) = (0, 0);\n            let segments = self.get_sorted_segment();\n            let mut answers = vec![None; self.q];\n\n            for segment in segments.into_iter() {\n                let l_next = segment.l;\n                let r_next = segment.r;\n\n                if r &lt; r_next {\n                    for i in r..r_next {\n                        p.add_id(i);\n                    }\n\n                    if l &lt; l_next {\n                        for i in l..l_next {\n                            p.erase_id(i);\n                        }\n                    } else {\n                        for i in (l_next..l).rev() {\n                            p.add_id(i);\n                        }\n                    }\n                } else {\n                    if l &lt; l_next {\n                        for i in l..l_next {\n                            p.erase_id(i);\n                        }\n                    } else {\n                        for i in (l_next..l).rev() {\n                            p.add_id(i);\n                        }\n                    }\n\n                    for i in (r_next..r).rev() {\n                        p.erase_id(i);\n                    }\n                }\n                answers[segment.query_id] = Some(p.answer());\n\n                l = l_next;\n                r = r_next;\n            }\n\n            answers.into_iter().map(|ans| ans.unwrap()).collect_vec()\n        }\n    }\n}\n</code></pre>"},{"location":"data_structure/mo_algorithm/#example","title":"Example","text":"<ul> <li>ABC174 F - Range Set Query (Rust)</li> <li>ABC238 G - Cubic? (C++)</li> <li>ABC242 G - Range Pairing Query (Rust)</li> <li>ABC293 G - Triple Index (Rust)</li> </ul>"},{"location":"data_structure/segment_tree/","title":"Segment tree","text":""},{"location":"data_structure/segment_tree/#c","title":"c++","text":"<pre><code>template &lt;class S, S (*op)(S, S), S (*e)()&gt; struct SegmentTree {\n  public:\n    SegmentTree() : SegmentTree(0) {}\n    SegmentTree(int n) : SegmentTree(std::vector&lt;S&gt;(n, e())) {}\n    SegmentTree(const std::vector&lt;S&gt;&amp; v) : _n(int(v.size())) {\n        log = ceil_pow2(_n);\n        size = 1 &lt;&lt; log;\n        d = std::vector&lt;S&gt;(2 * size, e());\n        for (int i = 0; i &lt; _n; i++) d[size + i] = v[i];\n        for (int i = size - 1; i &gt;= 1; i--) {\n            update(i);\n        }\n    }\n\n    void set(int p, S x) {\n        assert(0 &lt;= p &amp;&amp; p &lt; _n);\n        p += size;\n        d[p] = x;\n        for (int i = 1; i &lt;= log; i++) update(p &gt;&gt; i);\n    }\n\n    S get(int p) {\n        assert(0 &lt;= p &amp;&amp; p &lt; _n);\n        return d[p + size];\n    }\n\n    S prod(int l, int r) {\n        assert(0 &lt;= l &amp;&amp; r &lt;= _n);\n        S sml = e(), smr = e();\n        l += size;\n        r += size;\n\n        while (l &lt; r) {\n            if (l &amp; 1) sml = op(sml, d[l++]);\n            if (r &amp; 1) smr = op(d[--r], smr);\n            l &gt;&gt;= 1;\n            r &gt;&gt;= 1;\n        }\n        return op(sml, smr);\n    }\n\n    S all_prod() { return d[1]; }\n\n    template &lt;class F&gt; int max_right(int l, F f) {\n        assert(0 &lt;= l &amp;&amp; l &lt;= _n);\n        assert(f(e()));\n        if (l == _n) return _n;\n        l += size;\n        S sm = e();\n        do {\n            while (l % 2 == 0) l &gt;&gt;= 1;\n            if (!f(op(sm, d[l]))) {\n                while (l &lt; size) {\n                    l = (2 * l);\n                    if (f(op(sm, d[l]))) {\n                        sm = op(sm, d[l]);\n                        l++;\n                    }\n                }\n                return l - size;\n            }\n            sm = op(sm, d[l]);\n            l++;\n        } while ((l &amp; -l) != l);\n        return _n;\n    }\n\n    template &lt;class F&gt; int min_left(int r, F f) {\n        assert(0 &lt;= r &amp;&amp; r &lt;= _n);\n        assert(f(e()));\n        if (r == 0) return 0;\n        r += size;\n        S sm = e();\n        do {\n            r--;\n            while (r &gt; 1 &amp;&amp; (r % 2)) r &gt;&gt;= 1;\n            if (!f(op(d[r], sm))) {\n                while (r &lt; size) {\n                    r = (2 * r + 1);\n                    if (f(op(d[r], sm))) {\n                        sm = op(d[r], sm);\n                        r--;\n                    }\n                }\n                return r + 1 - size;\n            }\n            sm = op(d[r], sm);\n        } while ((r &amp; -r) != r);\n        return 0;\n    }\n\n  private:\n    int _n, size, log;\n    std::vector&lt;S&gt; d;\n\n    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n\n    int ceil_pow2(int n) {\n        int x = 0;\n        while ((1U &lt;&lt; x) &lt; (unsigned int)(n)) x++;\n        return x;\n    }\n};\n</code></pre>"},{"location":"data_structure/segment_tree/#rust","title":"Rust","text":"<pre><code>pub mod segtree {\n    pub trait Monoid {\n        fn e() -&gt; Self;\n        fn op(&amp;self, rhs: Self) -&gt; Self;\n    }\n\n    pub struct SegmentTree&lt;T&gt; {\n        n: usize,\n        val: Vec&lt;T&gt;,\n    }\n\n    impl&lt;T: Monoid + Copy&gt; SegmentTree&lt;T&gt; {\n        pub fn from_length(n: usize) -&gt; Self {\n            let val = vec![T::e(); n];\n            Self::build(val)\n        }\n\n        pub fn from_array(v: &amp;[T]) -&gt; Self {\n            let val = v.to_vec();\n            Self::build(val)\n        }\n\n        fn build(v: Vec&lt;T&gt;) -&gt; Self {\n            let m = v.len();\n            let mut n = 1;\n            while n &lt; m {\n                n &lt;&lt;= 1;\n            }\n\n            let mut val = vec![T::e(); n]; // n\n            val.extend(v); // n + m\n            val.extend(vec![T::e(); n - m]); // 2n\n\n            for i in (1..n).rev() {\n                let l = i &lt;&lt; 1 + 0;\n                let r = (i &lt;&lt; 1) + 1;\n                val[i] = val[l].op(val[r]);\n            }\n\n            Self { n, val }\n        }\n\n        pub fn get(&amp;self, pos: usize) -&gt; T {\n            self.val[pos + self.n]\n        }\n\n        pub fn set(&amp;mut self, pos: usize, x: T) {\n            let mut i = pos + self.n;\n            self.val[i] = x;\n            while i &gt; 1 {\n                i &gt;&gt;= 1;\n                let l = i &lt;&lt; 1 + 0;\n                let r = (i &lt;&lt; 1) + 1;\n                self.val[i] = self.val[l].op(self.val[r]);\n            }\n        }\n\n        pub fn prod(&amp;self, mut l: usize, mut r: usize) -&gt; T {\n            l += self.n;\n            r += self.n;\n            let mut v = T::e();\n            while l &lt; r {\n                if (l &amp; 1) == 1 {\n                    v = v.op(self.val[l]);\n                    l += 1;\n                }\n                if (r &amp; 1) == 1 {\n                    r -= 1;\n                    v = v.op(self.val[r]);\n                }\n                l &gt;&gt;= 1;\n                r &gt;&gt;= 1;\n            }\n\n            v\n        }\n    }\n}\n</code></pre>"},{"location":"data_structure/segment_tree_beats/","title":"Segment tree beats","text":""},{"location":"data_structure/segment_tree_beats/#c","title":"c++","text":"<pre><code>struct SegmentTreeBeats{\n    const long long LINF = 1LL&lt;&lt;60;\n    int n;\n    vector&lt;long long&gt; sum;\n    vector&lt;long long&gt; f_max, s_max, n_max;\n    vector&lt;long long&gt; f_min, s_min, n_min;\n    vector&lt;long long&gt; len, ladd, lval;\n\n    SegmentTreeBeats(vector&lt;long long&gt; a){\n        int sz = a.size();\n        n = 1;\n        while(n &lt; sz) n &lt;&lt;= 1;\n\n        sum.resize(2*n-1, 0);\n\n        f_max.resize(2*n-1, -LINF);\n        s_max.resize(2*n-1, -LINF);\n        n_max.resize(2*n-1, 0);\n\n        f_min.resize(2*n-1, LINF);\n        s_min.resize(2*n-1, LINF);\n        n_min.resize(2*n-1, 0);\n\n        ladd.resize(2*n-1, 0);\n        lval.resize(2*n-1, LINF);\n        len.resize(2*n-1);\n\n        len[0] = n;\n        for(int i=0; i&lt;n-1; ++i) len[2*i+1] = len[2*i+2] = (len[i]&gt;&gt;1);\n\n        for(int i=0; i&lt;sz; ++i){\n            f_max[i+n-1] = f_min[i+n-1] = sum[i+n-1] = a[i];\n            n_max[i+n-1] = n_min[i+n-1] = 1;\n        }\n\n        for(int i=n-2; i&gt;=0; --i) _update(i);\n    }\n\n    void _update_node_max(int k, long long x){\n        sum[k] += (x-f_max[k]) * n_max[k];\n\n        if(f_max[k] == f_min[k]) f_max[k] = f_min[k] = x;\n        else if(f_max[k] == s_min[k]) f_max[k] = s_min[k] = x;\n        else f_max[k] = x;\n\n        if(lval[k] != LINF &amp;&amp; x &lt; lval[k]) lval[k] = x;\n\n        return;\n    }\n\n    void _update_node_min(int k, long long x) {\n        sum[k] += (x-f_min[k]) * n_min[k];\n\n        if(f_max[k] == f_min[k]) f_max[k] = f_min[k] = x;\n        else if(s_max[k] == f_min[k]) s_max[k] = f_min[k] = x;\n        else f_min[k] = x;\n\n        if(lval[k] != LINF &amp;&amp; lval[k] &lt; x) lval[k] = x;\n\n        return;\n    }\n\n    void _update_node_add(int k, long long x){\n        f_max[k] += x;\n        if(s_max[k] != -LINF) s_max[k] += x;\n\n        f_min[k] += x;\n        if(s_min[k] != LINF) s_min[k] += x;\n\n        sum[k] += len[k] * x;\n        if(lval[k] != LINF) lval[k] += x;\n        else ladd[k] += x;\n\n        return;\n    }\n\n    void _update_node_assign(int k, long long x){\n        f_max[k] = x; s_max[k] = -LINF;\n        f_min[k] = x; s_min[k] = LINF;\n        n_max[k] = n_min[k] = len[k];\n\n        sum[k] = x * len[k];\n        lval[k] = x; ladd[k] = 0;\n\n        return;\n    }\n\n    void _pushdown(int k){\n        if(n-1 &lt;= k) return;\n\n        if(lval[k] != LINF){\n            _update_node_assign(2*k+1, lval[k]);\n            _update_node_assign(2*k+2, lval[k]);\n            lval[k] = LINF;\n            return;\n        }\n\n        if(ladd[k] != 0){\n            _update_node_add(2*k+1, ladd[k]);\n            _update_node_add(2*k+2, ladd[k]);\n            ladd[k] = 0;\n        }\n\n        if(f_max[k] &lt; f_max[2*k+1]) _update_node_max(2*k+1, f_max[k]);\n        if(f_max[k] &lt; f_max[2*k+2]) _update_node_max(2*k+2, f_max[k]);\n\n        if(f_min[2*k+1] &lt; f_min[k]) _update_node_min(2*k+1, f_min[k]);\n        if(f_min[2*k+2] &lt; f_min[k]) _update_node_min(2*k+2, f_min[k]);\n\n        return;\n    }\n\n    void _update(int k){\n        if(n-1 &lt;= k) return;\n\n        sum[k] = sum[2*k+1] + sum[2*k+2];\n\n        if(f_max[2*k+1] &lt; f_max[2*k+2]){\n            f_max[k] = f_max[2*k+2];\n            n_max[k] = n_max[2*k+2];\n            s_max[k] = max(f_max[2*k+1], s_max[2*k+2]);\n        }\n        else if(f_max[2*k+1] &gt; f_max[2*k+2]){\n            f_max[k] = f_max[2*k+1];\n            n_max[k] = n_max[2*k+1];\n            s_max[k] = max(s_max[2*k+1], f_max[2*k+2]);\n        }\n        else{\n            f_max[k] = f_max[2*k+1];\n            n_max[k] = n_max[2*k+1] + n_max[2*k+2];\n            s_max[k] = max(s_max[2*k+1], s_max[2*k+2]);\n        }\n\n        if(f_min[2*k+1] &lt; f_min[2*k+2]){\n            f_min[k] = f_min[2*k+1];\n            n_min[k] = n_min[2*k+1];\n            s_min[k] = min(s_min[2*k+1], f_min[2*k+2]);\n        }\n        else if(f_min[2*k+1] &gt; f_min[2*k+2]){\n            f_min[k] = f_min[2*k+2];\n            n_min[k] = n_min[2*k+2];\n            s_min[k] = min(f_min[2*k+1], s_min[2*k+2]);\n        }\n        else{\n            f_min[k] = f_min[2*k+1];\n            n_min[k] = n_min[2*k+1] + n_min[2*k+2];\n            s_min[k] = min(s_min[2*k+1], s_min[2*k+2]);\n        }\n\n        return;\n    }\n\n    void update_min(int a, int b, long long x, int k=0, int l=0, int r=-1){\n        if(r&lt;0) r = n;\n\n        // break condition\n        if(b&lt;=l || r&lt;=a || f_max[k]&lt;=x) return;\n        // tag condition\n        if(a&lt;=l &amp;&amp; r&lt;=b &amp;&amp; s_max[k]&lt;x){\n            _update_node_max(k, x);\n            return;\n        }\n\n        _pushdown(k);\n        update_min(a, b, x, 2*k+1, l, (l+r)/2);\n        update_min(a, b, x, 2*k+2, (l+r)/2, r);\n        _update(k);\n\n        return;\n    }\n\n    void update_max(int a, int b, long long x, int k=0, int l=0, int r=-1) {\n        if(r&lt;0) r = n;\n\n        if(b&lt;=l || r&lt;=a || x&lt;=f_min[k]) return;\n        if(a&lt;=l &amp;&amp; r&lt;=b &amp;&amp; x&lt;s_min[k]){\n            _update_node_min(k, x);\n            return;\n        }\n\n        _pushdown(k);\n        update_max(a, b, x, 2*k+1, l, (l+r)/2);\n        update_max(a, b, x, 2*k+2, (l+r)/2, r);\n        _update(k);\n    }\n\n    void update_add(int a, int b, long long x, int k=0, int l=0, int r=-1){\n        if(r&lt;0) r = n;\n\n        if(b&lt;=l || r&lt;=a) return;\n        if(a&lt;=l &amp;&amp; r&lt;=b){\n            _update_node_add(k, x);\n            return;\n        }\n\n        _pushdown(k);\n        update_add(a, b, x, 2*k+1, l, (l+r)/2);\n        update_add(a, b, x, 2*k+2, (l+r)/2, r);\n        _update(k);\n    }\n\n    void update_assign(int a, int b, long long x, int k=0, int l=0, int r=-1){\n        if(r&lt;0) r = n;\n\n        if(b&lt;=l || r&lt;=a) return;\n        if(a&lt;=l &amp;&amp; r&lt;=b){\n            _update_node_assign(k, x);\n            return;\n        }\n\n        _pushdown(k);\n        update_assign(a, b, x, 2*k+1, l, (l+r)/2);\n        update_assign(a, b, x, 2*k+2, (l+r)/2, r);\n        _update(k);\n    }\n\n    long long query_max(int a, int b, int k=0, int l=0, int r=-1){\n        if(r&lt;0) r = n;\n\n        if(b&lt;=l || r&lt;=a) return 0;\n        if(a&lt;=l &amp;&amp; r&lt;=b) return f_max[k];\n\n        _pushdown(k);\n        long long lv = query_max(a, b, 2*k+1, l, (l+r)/2);\n        long long rv = query_max(a, b, 2*k+2, (l+r)/2, r);\n        return max(lv, rv);\n    }\n\n    long long query_min(int a, int b, int k=0, int l=0, int r=-1){\n        if(r&lt;0) r = n;\n\n        if(b&lt;=l || r&lt;=a) return LINF;\n        if(a&lt;=l &amp;&amp; r&lt;=b) return f_min[k];\n\n        _pushdown(k);\n        long long lv = query_min(a, b, 2*k+1, l, (l+r)/2);\n        long long rv = query_min(a, b, 2*k+2, (l+r)/2, r);\n        return min(lv, rv);\n    }\n\n    long long query_sum(int a, int b, int k=0, int l=0, int r=-1){\n        if(r&lt;0) r = n;\n\n        if(b&lt;=l || r&lt;=a) return 0;\n        if(a&lt;=l &amp;&amp; r&lt;=b) return sum[k];\n\n        _pushdown(k);\n        long long lv = query_sum(a, b, 2*k+1, l, (l+r)/2);\n        long long rv = query_sum(a, b, 2*k+2, (l+r)/2, r);\n        return lv+rv;\n    }\n};\n</code></pre>"},{"location":"data_structure/slope_trick/","title":"Slope trick","text":""},{"location":"data_structure/slope_trick/#c","title":"C++","text":"<pre><code>template &lt;class T = int&gt;\nstruct SlopeTrick {\n\n    SlopeTrick(T inf) : inf(inf) {\n        ql.push(-inf);\n        qr.push(inf);\n    }\n\n    void add_slope_l(T a) {\n        // add f(x) = max(0, a-x)\n        T r0 = qr.top();\n        m += std::max(T(0), a - r0);\n\n        a -= num_shift;\n        qr.push(a);\n        T b = qr.top();\n        qr.pop();\n        ql.push(b);\n    }\n\n    void add_slope_r(T a) {\n        // add f(x) = max(0, x-a)\n        T l0 = ql.top();\n        m += std::max(T(0), l0 - a);\n\n        a -= num_shift;\n        ql.push(a);\n        T b = ql.top();\n        ql.pop();\n        qr.push(b);\n    }\n\n    void add_const(T a) {\n        // add f(x) = a\n        m += a;\n    }\n\n    void shift(T a) {\n        // f(x) &lt;- f(x-a)\n        num_shift += a;\n    }\n\n    void cummin_l() {\n        // f(x) &lt;- min_{y &lt;= x} f(y)\n        while (qr.size() &gt; 1) {\n            qr.pop();\n        }\n    }\n\n    void cummin_r() {\n        // f(x) &lt;- min_{x &lt;= y} f(y)\n        while (ql.size() &gt; 1) {\n            ql.pop();\n        }\n    }\n\n    T min() {\n        // min f(x)\n        return m;\n    }\n\n    T argmin() {\n        // argmin f(x)\n        T a = ql.top();\n        if (a != -inf)\n            a += num_shift;\n        return a;\n    }\n\n  private:\n    std::priority_queue&lt;T, std::vector&lt;T&gt;, std::greater&lt;T&gt;&gt; qr;\n    std::priority_queue&lt;T&gt; ql;\n    T m = 0, num_shift = 0, inf;\n};\n</code></pre>"},{"location":"data_structure/slope_trick/#example","title":"Example","text":"<ul> <li>ABC127 F - Absolute Minima (C++)</li> </ul>"},{"location":"data_structure/slope_trick/#reference","title":"Reference","text":"<ul> <li>https://maspypy.com/slope-trick-1-%E8%A7%A3%E8%AA%AC%E7%B7%A8</li> </ul>"},{"location":"data_structure/trie/","title":"Trie","text":""},{"location":"data_structure/trie/#c","title":"C++","text":"<pre><code>template&lt;int size, int base&gt;\nstruct Trie {\n    vector&lt;vector&lt;int&gt;&gt; dat;\n    vector&lt;int&gt; init, depth;\n\n    Trie(): Trie(vector&lt;string&gt;{}) {}\n    Trie(const vector&lt;string&gt;&amp; v){\n        init.resize(size, -1);\n        depth.push_back(0);\n        dat.push_back(init);\n\n        for(string s : v) insert(s);\n    }\n\n    void insert(const string&amp; s){\n        int pos = 0;\n        for(char c : s){\n            int x = c - base;\n            if(dat[pos][x] == -1){\n                dat[pos][x] = dat.size();\n                dat.push_back(init);\n                depth.push_back(depth[pos]+1);\n            }\n            pos = dat[pos][x];\n        }\n    }\n\n    bool exist(const string&amp; s){\n        int pos = 0;\n        for(char&amp; c : s){\n            int x = c - base;\n            if(dat[pos][x] == -1) return false;\n            pos = dat[pos][x];\n        }\n        return true;\n    }\n};\n</code></pre>"},{"location":"data_structure/trie/#rust","title":"Rust","text":"<pre><code>mod trie {\n    use num_traits::PrimInt;\n\n    pub struct Trie&lt;T: PrimInt&gt; {\n        child: Vec&lt;Vec&lt;Option&lt;usize&gt;&gt;&gt;,\n        num_data: Vec&lt;u32&gt;,\n        num_eos: Vec&lt;u32&gt;,\n        size: usize,\n        base: T,\n    }\n\n    impl&lt;T: PrimInt&gt; Trie&lt;T&gt; {\n        pub fn new(size: usize, base: T) -&gt; Self {\n            let child = vec![vec![None; size]];\n            let num_data = vec![0];\n            let num_eos = vec![0];\n\n            Self {\n                child,\n                num_data,\n                num_eos,\n                size,\n                base,\n            }\n        }\n\n        pub fn insert(&amp;mut self, x: &amp;Vec&lt;T&gt;) {\n            let mut pos = 0;\n\n            for &amp;xi in x.iter() {\n                let index = (xi - self.base).to_usize().unwrap();\n\n                if self.child[pos][index].is_none() {\n                    self.insert_node(pos, index);\n                }\n\n                self.num_data[pos] += 1;\n                pos = self.child[pos][index].unwrap();\n            }\n            self.num_data[pos] += 1;\n            self.num_eos[pos] += 1;\n        }\n\n        pub fn erase(&amp;mut self, x: &amp;Vec&lt;T&gt;) -&gt; bool {\n            if let Some(path) = self.get_path(x) {\n                let last_pos = *path.last().unwrap();\n                if self.num_eos[last_pos] == 0 {\n                    return false;\n                }\n\n                self.num_eos[last_pos] -= 1;\n\n                for pos in path.into_iter() {\n                    self.num_data[pos] -= 1;\n                }\n                return true;\n            }\n            false\n        }\n\n        /// x\u304c\u5b58\u5728\u3059\u308b\u304b\u3069\u3046\u304b\n        pub fn exists(&amp;self, x: &amp;Vec&lt;T&gt;) -&gt; bool {\n            if let Some(path) = self.get_path(x) {\n                let last_pos = *path.last().unwrap();\n                return self.num_eos[last_pos] &gt; 0;\n            }\n            false\n        }\n\n        pub fn get_kth(&amp;self, k: usize) -&gt; Option&lt;Vec&lt;T&gt;&gt; {\n            if self.num_data[0] &lt; k as u32 {\n                return None;\n            }\n\n            let mut cumsum = 0;\n            let mut pos = 0;\n            let mut val = vec![];\n\n            loop {\n                for i in 0..self.size {\n                    if let Some(next) = self.child[pos][i] {\n                        if cumsum + self.num_data[next] &lt; k as u32 {\n                            cumsum += self.num_data[next];\n                        } else {\n                            pos = next;\n                            val.push(self.base + T::from(i).unwrap());\n                            break;\n                        }\n                    }\n                }\n\n                if cumsum + self.num_eos[pos] &gt;= k as u32 {\n                    break;\n                }\n            }\n\n            Some(val)\n        }\n\n        fn get_node(&amp;self) -&gt; Vec&lt;Option&lt;usize&gt;&gt; {\n            let child = vec![None; self.size];\n            child\n        }\n\n        fn get_next_index(&amp;self) -&gt; usize {\n            self.child.len()\n        }\n\n        /// pos\u756a\u306enode\u306eindex\u756a\u76ee\u306bnode\u3092\u8ffd\u52a0\u3059\u308b\n        fn insert_node(&amp;mut self, pos: usize, index: usize) {\n            let new_index = self.get_next_index();\n            self.child[pos][index] = Some(new_index);\n\n            let child = self.get_node();\n            self.child.push(child);\n            self.num_data.push(0);\n            self.num_eos.push(0);\n        }\n\n        /// x\u3092\u8fbf\u308b\u3088\u3046\u306anode\u306e\u756a\u53f7\u306e\u30ea\u30b9\u30c8\u3092\u53d6\u5f97\u3059\u308b\n        /// \u5b58\u5728\u3057\u306a\u3044\u5834\u5408\u306fNone\u3092\u8fd4\u3059\n        fn get_path(&amp;self, x: &amp;Vec&lt;T&gt;) -&gt; Option&lt;Vec&lt;usize&gt;&gt; {\n            let mut path = vec![0];\n            let mut pos = 0;\n\n            for &amp;xi in x.iter() {\n                let index = (xi - self.base).to_usize().unwrap();\n                if self.child[pos][index].is_none() {\n                    return None;\n                }\n                pos = self.child[pos][index].unwrap();\n                path.push(pos);\n            }\n\n            Some(path)\n        }\n    }\n}\n</code></pre>"},{"location":"data_structure/trie/#example","title":"Example","text":"<ul> <li>ARC033 C - \u30c7\u30fc\u30bf\u69cb\u9020 (Rust)</li> </ul>"},{"location":"data_structure/union_find/","title":"Union find","text":""},{"location":"data_structure/union_find/#c","title":"c++","text":"<pre><code>struct UnionFind{\n    vector&lt;int&gt; par; // par[i]:i\u306e\u89aa\u306e\u756a\u53f7\n    vector&lt;int&gt; s; // s[i]:i\u306e\u5c5e\u3059\u308b\u6728\u306e\u30ce\u30fc\u30c9\u6570\n    int n_group; // \u6728\u306e\u6570\n\n    UnionFind(int N) : par(N) {\n        for(int i=0; i&lt;N; i++) par[i] = i;\n        s.assign(N, 1);\n        n_group = N;\n    }\n\n    int root(int x){ // x\u304c\u5c5e\u3059\u308b\u6728\u306e\u6839\n        if(par[x] == x) return x;\n        return par[x] = root(par[x]);\n    }\n\n    void unite(int x, int y){ // x\u3068y\u306e\u6728\u3092\u4f75\u5408\n        int rx = root(x);\n        int ry = root(y);\n        if(rx == ry) return;\n        par[rx] = ry;\n        s[ry] += s[rx];\n        s[rx] = 0;\n        n_group--;\n    }\n\n    bool same(int x, int y){ // x\u3068y\u304c\u540c\u3058\u6728\u306b\u5c5e\u3059\u308b\u304b\u3069\u3046\u304b\n        return root(x) == root(y);\n    }\n\n    int size(int x){ // x\u304c\u5c5e\u3059\u308b\u6728\u306e\u30ce\u30fc\u30c9\u6570\n        return s[root(x)];\n    }\n};\n</code></pre>"},{"location":"data_structure/union_find_add/","title":"Union find add","text":""},{"location":"data_structure/union_find_add/#c","title":"c++","text":"<pre><code>struct UnionFind{\n    vector&lt;int&gt; par; // par[i]:i\u306e\u89aa\u306e\u756a\u53f7\n    vector&lt;int&gt; s; // s[i]:i\u306e\u5c5e\u3059\u308b\u6728\u306e\u30ce\u30fc\u30c9\u6570\n    int n_group; // \u6728\u306e\u6570\n    VI val;\n\n    UnionFind(int N) : par(N) {\n        for(int i=0; i&lt;N; i++) par[i] = i;\n        s.resize(N, 1);\n        n_group = N;\n        val.resize(N,0);\n    }\n\n    int root(int x){ // x\u304c\u5c5e\u3059\u308b\u6728\u306e\u6839\n        if(par[x] == x) return x;\n        int p = par[x];\n        par[x] = root(par[x]);\n        if(p != par[x]) val[x] += val[p];\n        return par[x];\n    }\n\n    void unite(int x, int y){ // x\u3068y\u306e\u6728\u3092\u4f75\u5408\n        int rx = root(x);\n        int ry = root(y);\n        if(rx == ry) return;\n        if(s[rx] &gt; s[ry]) swap(rx, ry);\n        par[rx] = ry;\n        val[rx] -= val[ry];\n        s[ry] += s[rx];\n        s[rx] = 0;\n        n_group--;\n    }\n\n    bool same(int x, int y){ // x\u3068y\u304c\u540c\u3058\u6728\u306b\u5c5e\u3059\u308b\u304b\u3069\u3046\u304b\n        return root(x) == root(y);\n    }\n\n    int size(int x){ // x\u304c\u5c5e\u3059\u308b\u6728\u306e\u30ce\u30fc\u30c9\u6570\n        return s[root(x)];\n    }\n\n    void add(int pos, int x){\n        int r = root(pos);\n        val[r] += x;\n    }\n\n    int query(int pos){\n        int r = root(pos);\n        return r == pos ? val[pos] : val[r] + val[pos];\n    }\n};\n</code></pre>"},{"location":"data_structure/wavelet_matrix/","title":"Wavelet matrix","text":""},{"location":"data_structure/wavelet_matrix/#c","title":"c++","text":"<pre><code>struct BitArray{\n    uint64_t n;\n    static const uint64_t b = 64;\n    static const uint64_t l = 512;\n    static const uint64_t s = 64;\n    static const uint64_t MASK = (1LLU&lt;&lt;63)-1 + (1LLU&lt;&lt;63);\n\n    vector&lt;uint64_t&gt; B;\n    vector&lt;uint64_t&gt; L, S;\n\n    BitArray() {}\n    BitArray(vector&lt;bool&gt;&amp; a){\n        uint64_t sz = a.size();\n        uint64_t szB,szL,szS;\n        szB = (sz + b-1) / b;\n        szL = (sz + l-1) / l;\n        szS = l/s*szL;\n\n        B.assign(szB,0);\n        L.assign(szL,0);\n        S.assign(szS,0);\n\n        for(uint64_t i=0; i&lt;sz; ++i){\n            if(!a[i]) continue;\n            uint64_t bpos = i/b, offset = b - i%b - 1;\n            B[bpos] |= 1LLU&lt;&lt;offset;\n        }\n\n        for(uint64_t i=0; i&lt;(szL-1)*l; ++i){\n            uint64_t lpos = i/l+1;\n            L[lpos] += a[i];\n        }\n\n        uint64_t num = 0;\n        for(uint64_t i=0; i&lt;szS*s; ++i){\n            if(i%s == 0){\n                uint64_t spos = i/s, lpos = i/l;\n                S[spos] = num - L[lpos];\n            }\n            if(i&lt;sz) num += a[i];\n        }\n    }\n\n    uint64_t pop_count(uint64_t x) {\n        x = (x &amp; 0x5555555555555555ULL) + ((x &gt;&gt; 1) &amp; 0x5555555555555555ULL);\n        x = (x &amp; 0x3333333333333333ULL) + ((x &gt;&gt; 2) &amp; 0x3333333333333333ULL);\n        x = (x + (x &gt;&gt; 4)) &amp; 0x0f0f0f0f0f0f0f0fULL;\n        x = x + (x &gt;&gt;  8);\n        x = x + (x &gt;&gt; 16);\n        x = x + (x &gt;&gt; 32);\n        return x &amp; 0x7FLLU;\n    }\n\n    uint64_t access(int pos){\n        int bpos = pos/b, bit = b-1-pos%b;\n        uint64_t ret = (B[bpos]&gt;&gt;bit) &amp; 1;\n        return ret;\n    }\n\n    uint64_t rank(int pos, int bit){\n        int bpos = pos/b, lpos = pos/l, spos = pos/s;\n        int nbit = b-pos%b -1;\n        uint64_t mask = MASK - ((1LLU&lt;&lt;nbit)-1 + (1LLU&lt;&lt;nbit));\n        uint64_t n = L[lpos] + S[spos] + pop_count(B[bpos] &amp; mask);\n        uint64_t ret = bit ? n : pos-n;\n        return ret;\n    }\n\n    uint64_t select(int n, int bit){\n\n        // L\u5185\u3067\u4e8c\u5206\u63a2\u7d22\n        int ok=0, ng=L.size();\n        while(ng-ok&gt;1){\n            int pos = (ok+ng)/2;\n            int k = bit ? L[pos] : l*pos - L[pos];\n            if(k &lt; n) ok = pos;\n            else ng = pos;\n        }\n        int lpos = ok;\n\n        // S\u5185\u3067\u4e8c\u5206\u63a2\u7d22\n        ok=l*lpos/s, ng=ok+l/s;\n        while(ng-ok&gt;1){\n            int pos = (ok+ng)/2;\n            int k = bit ? L[lpos]+S[pos] : l*lpos+s*pos - (L[lpos]+S[pos]);\n            if(k &lt; n) ok = pos;\n            else ng = pos;\n        }\n        int spos = ok;\n\n        // B\u5185\u3067\u4e8c\u5206\u63a2\u7d22\n        int bpos = s*spos/b;\n        int tmp = bit ? L[lpos]+S[spos] : l*lpos+s*spos - (L[lpos]+S[spos]);\n        ok=0, ng=b;\n        while(ng-ok&gt;1){\n            int nbit = (ok+ng)/2;\n            uint64_t mask = MASK - (1LLU&lt;&lt;nbit) + 1;\n            int k = tmp + (bit ? pop_count(B[bpos] &amp; mask) : b-pop_count(B[bpos] &amp; mask)-nbit);\n            if(k &lt; n) ng = nbit;\n            else ok = nbit;\n        }\n        int nbit = b-ok;\n\n        uint64_t ret = l*lpos + s*spos + nbit;\n        return ret;\n    }\n};\n\nstruct WaveletMatlix{\n    static const uint64_t MASK = (1LLU&lt;&lt;63)-1 + (1LLU&lt;&lt;63);\n    int N, LOGA;\n    vector&lt;BitArray&gt; ba;\n    vector&lt;int&gt; nzero;\n    map&lt;int,int&gt; begin;\n\n    WaveletMatlix(vector&lt;int&gt; A){\n        N = A.size();\n        uint64_t mx = 0; for(int i=0; i&lt;N; ++i) mx = max(mx, (uint64_t)A[i]);\n\n        LOGA = floor(log2(mx));\n        ba.resize(LOGA+1);\n        nzero.resize(LOGA+1,0);\n\n        for(int i=LOGA; i&gt;=0; --i){\n            vector&lt;bool&gt; a(N);\n            for(int j=0; j&lt;N; ++j) a[j] = (A[j]&gt;&gt;i)&amp;1;\n            ba[i] = BitArray(a);\n\n            vector&lt;int&gt; o,z;\n            for(int j=0; j&lt;N; j++){\n                if((A[j]&gt;&gt;i) &amp; 1) o.push_back(A[j]);\n                else z.push_back(A[j]);\n            }\n\n            nzero[i] = z.size();\n            z.insert(z.end(), o.begin(), o.end());\n            swap(A,z);\n        }\n\n        for(int i=0; i&lt;N; ++i){\n            if(begin.find(A[i]) != begin.end()) continue;\n            begin[A[i]] = i;\n        }\n    }\n\n    uint64_t access(int pos){\n        uint64_t ret = 0;\n        for(int i=LOGA; i&gt;=0; --i){\n            int b = ba[i].access(pos);\n            if(b){\n                pos = nzero[i] + ba[i].rank(pos,1);\n            }\n            else{\n                pos = ba[i].rank(pos,0);\n            }\n            ret = (ret&lt;&lt;1) + b;\n        }\n        return ret;\n    }\n\n    uint64_t rank(int pos, int x){\n        // pos: 0-indexed\n        // [0,pos)\u306bx\u304c\u3044\u304f\u3064\u3042\u308b\u304b\n        if(begin.find(x) == begin.end()) return 0;\n\n        for(int i=LOGA; i&gt;=0; --i){\n            int o,z;\n            if((x&gt;&gt;i) &amp; 1){\n                o = ba[i].rank(pos,1); z = nzero[i];\n                pos = o+z;\n            }\n            else{\n                z = ba[i].rank(pos,0);\n                pos = z;\n            }\n        }\n\n        uint64_t ret = max(0, pos-begin[x]);\n        return ret;\n    }\n\n    uint64_t rank(int l, int r, uint64_t x){\n        // pos: 0-indexed\n        // [l,r)\u306bx\u304c\u3044\u304f\u3064\u3042\u308b\u304b\n        return rank(r,x) - rank(l,x);\n    }\n\n    int select(int i, int x){\n        // i(&gt;0)\u756a\u76ee\u306ex\u306e\u6b21\u306e\u4f4d\u7f6e(0-indexed)\u3092\u6c42\u3081\u308b\n        if(begin.find(x) == begin.end()) return -1;\n        if(N&lt;=begin[x]+i-1) return -1;\n\n        int pos = begin[x]+i;\n        for(int i=0; i&lt;=LOGA; ++i){\n            if((x&gt;&gt;i) &amp; 1){\n                pos = ba[i].select(pos-nzero[i],1);\n            }\n            else{\n                pos = ba[i].select(pos,0);\n            }\n        }\n\n        return pos;\n    }\n\n    uint64_t quantile(int l, int r, int k){\n        // [l,r)\u3067k\u756a\u76ee\u306b\u5c0f\u3055\u3044\u5024\u3092\u6c42\u3081\u308b\n        int ret = 0;\n        for(int i=LOGA; i&gt;=0; --i){\n            int o,z;\n            o = ba[i].rank(r,1) - ba[i].rank(l,1);\n            z = r-l-o;\n            if(k &lt;= z){\n                l = ba[i].rank(l,0);\n                r = l + z;\n                ret = ret&lt;&lt;1;\n            }\n            else{\n                l = nzero[i] + ba[i].rank(l,1);\n                r = l + o;\n                k -= z;\n                ret = (ret&lt;&lt;1) + 1;\n            }\n        }\n        return ret;\n    }\n\n    vector&lt;pair&lt;uint64_t,int&gt;&gt; topk(int l, int r, int k){\n        // [l,r)\u3067\u51fa\u73fe\u983b\u5ea6\u304c\u5927\u304d\u3044k\u500b\u3092(\u5024,\u983b\u5ea6)\u3067\u8fd4\u3059\n        // \u983b\u5ea6\u304c\u540c\u3058\u3082\u306e\u306f\u5024\u304c\u5c0f\u3055\u3044\u307b\u3046\u3092\u512a\u5148\n        auto c = [](tuple&lt;int,int,int,uint64_t&gt; a, tuple&lt;int,int,int,uint64_t&gt; b){\n            int width_a = get&lt;1&gt;(a) - get&lt;0&gt;(a);\n            int width_b = get&lt;1&gt;(b) - get&lt;0&gt;(b);\n            if(width_a != width_b) return width_a &lt; width_b;\n            else{\n                uint64_t val_a = get&lt;3&gt;(a), val_b = get&lt;3&gt;(b);\n                return val_a &gt; val_b;\n            }\n        };\n\n        vector&lt;pair&lt;uint64_t,int&gt;&gt; ret;\n        priority_queue&lt;tuple&lt;int,int,int,uint64_t&gt;,vector&lt;tuple&lt;int,int,int,uint64_t&gt;&gt;,decltype(c)&gt; q(c);\n        q.emplace(l,r,LOGA,0);\n        while(!q.empty() &amp;&amp; (int)ret.size()&lt;k){\n            tuple&lt;int,int,int,uint64_t&gt; t = q.top(); q.pop();\n\n            int depth = get&lt;2&gt;(t);\n            uint64_t val = get&lt;3&gt;(t);\n            if(depth &lt; 0){\n                int freq = get&lt;1&gt;(t) - get&lt;0&gt;(t);\n                ret.emplace_back(val,freq);\n            }\n            else{\n                int l = get&lt;0&gt;(t), r = get&lt;1&gt;(t), i = depth;\n                int z = ba[i].rank(r,0) - ba[i].rank(l,0);\n\n                int l1 = ba[i].rank(l,0), r1 = l1+z;\n                int l2 = nzero[i] + ba[i].rank(l,1), r2 = l2+r-l-z;\n                if(r1-l1&gt;0) q.emplace(l1,r1,depth-1,val);\n                if(r2-l2&gt;0) q.emplace(l2,r2,depth-1,val | (1LLU&lt;&lt;i));\n            }\n        }\n\n        return ret;\n    }\n\n    uint64_t sum(int l, int r){\n        // [l,r)\u306e\u7dcf\u548c\u3092\u8a08\u7b97\n        uint64_t ret = 0;\n        queue&lt;tuple&lt;int,int,int&gt;&gt; q;\n        q.emplace(l,r,LOGA);\n        while(!q.empty()){\n            tuple&lt;int,int,int&gt; t = q.front(); q.pop();\n\n            int i = get&lt;2&gt;(t);\n            if(0 &lt;= i){\n                int l = get&lt;0&gt;(t), r = get&lt;1&gt;(t);\n                int z = ba[i].rank(r,0) - ba[i].rank(l,0);\n                uint64_t o = r-l-z;\n                ret += o * (1LLU&lt;&lt;i);\n\n                int l1 = ba[i].rank(l,0), r1 = l1+z;\n                int l2 = nzero[i] + ba[i].rank(l,1), r2 = l2+r-l-z;\n                if(r1-l1&gt;0) q.emplace(l1,r1,i-1);\n                if(r2-l2&gt;0) q.emplace(l2,r2,i-1);\n            }\n        }\n\n        return ret;\n    }\n\n    uint64_t rangeLess(int l, int r, uint64_t x){\n        // [l,r)\u3067x\u672a\u6e80\u306e\u8981\u7d20\u6570\n        int LOGX = floor(log2(max(x,(uint64_t)1)));\n        if(LOGA &lt; LOGX) return r-l;\n\n        uint64_t ret = 0;\n        for(int i=LOGA; i&gt;=0; --i){\n            int o = ba[i].rank(r,1) - ba[i].rank(l,1);\n            int z = r-l-o;\n\n            if((x&gt;&gt;i) &amp; 1){\n                ret += z;\n                l = nzero[i] + ba[i].rank(l,1);\n                r = l+o;\n            }\n            else{\n                l = ba[i].rank(l,0);\n                r = l+z;\n            }\n        }\n        return ret;\n    }\n\n    uint64_t rangeFreq(int l, int r, uint64_t x, uint64_t y){\n        // [l,r)\u3067x&lt;=c&lt;y\u3068\u306a\u308bc\u306e\u500b\u6570\n        return rangeLess(l,r,y) - rangeLess(l,r,x);\n    }\n\n    vector&lt;pair&lt;uint64_t,int&gt;&gt; rangeList(int l, int r, uint64_t x, uint64_t y){\n        // [l,r)\u3067x&lt;=c&lt;y\u3068\u306a\u308bc\u3092\u983b\u5ea6\u3068\u5171\u306b\u8fd4\u3059\n        vector&lt;pair&lt;uint64_t,int&gt;&gt; ret;\n        stack&lt;tuple&lt;int,int,int,uint64_t&gt;&gt; stk;\n        stk.emplace(l,r,LOGA,0);\n        while(!stk.empty()){\n            tuple&lt;int,int,int,uint64_t&gt; t = stk.top(); stk.pop();\n            int i = get&lt;2&gt;(t);\n            uint64_t val = get&lt;3&gt;(t);\n\n            if(i&lt;0){\n                int freq = get&lt;1&gt;(t) - get&lt;0&gt;(t);\n                ret.emplace_back(val,freq);\n            }\n            else{\n                uint64_t val0 = val, val1 = val | (1LLU&lt;&lt;i);\n                uint64_t mask = MASK - (1LLU&lt;&lt;i) + 1;\n\n                int l = get&lt;0&gt;(t), r = get&lt;1&gt;(t);\n                if((x&amp;mask)&lt;=val1 &amp;&amp; val1&lt;y){\n                    int o = ba[i].rank(r,1) - ba[i].rank(l,1);\n                    int l1 = nzero[i] + ba[i].rank(l,1), r1 = l1+o;\n                    if(r1-l1&gt;0) stk.emplace(l1,r1,i-1,val1);\n                }\n                if((x&amp;mask)&lt;=val0 &amp;&amp; val0&lt;y){\n                    int z = ba[i].rank(r,0) - ba[i].rank(l,0);\n                    int l0 = ba[i].rank(l,0), r0 = l0+z;\n                    if(r0-l0&gt;0) stk.emplace(l0,r0,i-1,val0);\n                }\n            }\n        }\n\n        return ret;\n    }\n\n    vector&lt;pair&lt;uint64_t,int&gt;&gt; rangeMaxK(int l, int r, uint64_t x, uint64_t y, int k){\n        // [l,r)\u3067x&lt;=c&lt;y\u3068\u306a\u308bc\u3092\u5927\u304d\u3044\u9806\u306bk\u500b, \u983b\u5ea6\u3068\u5171\u306b\u8fd4\u3059\n        vector&lt;pair&lt;uint64_t,int&gt;&gt; ret;\n        stack&lt;tuple&lt;int,int,int,uint64_t&gt;&gt; stk;\n        stk.emplace(l,r,LOGA,0);\n        while(!stk.empty() &amp;&amp; (int)ret.size()&lt;k){\n            tuple&lt;int,int,int,uint64_t&gt; t = stk.top(); stk.pop();\n            int i = get&lt;2&gt;(t);\n            uint64_t val = get&lt;3&gt;(t);\n\n            if(i&lt;0){\n                int freq = get&lt;1&gt;(t) - get&lt;0&gt;(t);\n                ret.emplace_back(val,freq);\n            }\n            else{\n                uint64_t val0 = val, val1 = val | (1LLU&lt;&lt;i);\n                uint64_t mask = MASK - (1LLU&lt;&lt;i) + 1;\n\n                int l = get&lt;0&gt;(t), r = get&lt;1&gt;(t);\n                if((x&amp;mask)&lt;=val0 &amp;&amp; val0&lt;y){\n                    int z = ba[i].rank(r,0) - ba[i].rank(l,0);\n                    int l0 = ba[i].rank(l,0), r0 = l0+z;\n                    if(r0-l0&gt;0) stk.emplace(l0,r0,i-1,val0);\n                }\n                if((x&amp;mask)&lt;=val1 &amp;&amp; val1&lt;y){\n                    int o = ba[i].rank(r,1) - ba[i].rank(l,1);\n                    int l1 = nzero[i] + ba[i].rank(l,1), r1 = l1+o;\n                    if(r1-l1&gt;0) stk.emplace(l1,r1,i-1,val1);\n                }\n            }\n        }\n\n        return ret;\n    }\n\n    long long rangeMax(int l, int r, uint64_t x, uint64_t y){\n        vector&lt;pair&lt;uint64_t,int&gt;&gt; v = rangeMaxK(l,r,x,y,1);\n        return v.empty() ? -1 : v[0].first;\n    }\n\n    long long rangeMax(int l, int r){\n        return rangeMax(l,r,0,MASK);\n    }\n\n    vector&lt;pair&lt;uint64_t,int&gt;&gt; rangeMinK(int l, int r, uint64_t x, uint64_t y, int k){\n        // [l,r)\u3067x&lt;=c&lt;y\u3068\u306a\u308bc\u3092\u5c0f\u3055\u3044\u9806\u306bk\u500b, \u983b\u5ea6\u3068\u5171\u306b\u8fd4\u3059\n        vector&lt;pair&lt;uint64_t,int&gt;&gt; ret;\n        stack&lt;tuple&lt;int,int,int,uint64_t&gt;&gt; stk;\n        stk.emplace(l,r,LOGA,0);\n        while(!stk.empty() &amp;&amp; (int)ret.size()&lt;k){\n            tuple&lt;int,int,int,uint64_t&gt; t = stk.top(); stk.pop();\n            int i = get&lt;2&gt;(t);\n            uint64_t val = get&lt;3&gt;(t);\n\n            if(i&lt;0){\n                int freq = get&lt;1&gt;(t) - get&lt;0&gt;(t);\n                ret.emplace_back(val,freq);\n            }\n            else{\n                uint64_t val0 = val, val1 = val | (1LLU&lt;&lt;i);\n                uint64_t mask = MASK - (1LLU&lt;&lt;i) + 1;\n\n                int l = get&lt;0&gt;(t), r = get&lt;1&gt;(t);\n                if((x&amp;mask)&lt;=val1 &amp;&amp; val1&lt;y){\n                    int o = ba[i].rank(r,1) - ba[i].rank(l,1);\n                    int l1 = nzero[i] + ba[i].rank(l,1), r1 = l1+o;\n                    if(r1-l1&gt;0) stk.emplace(l1,r1,i-1,val1);\n                }\n                if((x&amp;mask)&lt;=val0 &amp;&amp; val0&lt;y){\n                    int z = ba[i].rank(r,0) - ba[i].rank(l,0);\n                    int l0 = ba[i].rank(l,0), r0 = l0+z;\n                    if(r0-l0&gt;0) stk.emplace(l0,r0,i-1,val0);\n                }\n            }\n        }\n\n        return ret;\n    }\n\n    long long rangeMin(int l, int r, uint64_t x, uint64_t y){\n        vector&lt;pair&lt;uint64_t,int&gt;&gt; v = rangeMinK(l,r,x,y,1);\n        return v.empty() ? -1 : v[0].first;\n    }\n\n    long long rangeMin(int l, int r){\n        return rangeMin(l,r,0,MASK);\n    }\n\n    vector&lt;tuple&lt;uint64_t, uint64_t, uint64_t&gt;&gt; intersect(int l1, int r1, int l2, int r2) {\n        // [l1,r1), [l2,r2)\u306b\u5171\u901a\u3057\u3066\u73fe\u308c\u308b\u8981\u7d20\u3092\u983b\u5ea6\u3068\u5171\u306b\u8fd4\u3059\n        // (\u5024, [l1,r1)\u3067\u306e\u983b\u5ea6, [l2,r2)\u3067\u306e\u983b\u5ea6)\n        vector&lt;tuple&lt;uint64_t,uint64_t,uint64_t&gt;&gt; ret;\n\n        queue&lt;tuple&lt;uint64_t,uint64_t,uint64_t,uint64_t,int,uint64_t&gt;&gt; que; // s1, e1, s2, e2, depth, value\n        que.push(make_tuple(l1, r1, l2, r2, LOGA, 0));\n        while (!que.empty()) {\n            auto e = que.front(); que.pop();\n            uint64_t s1, e1, s2, e2, val; int i;\n            tie(s1, e1, s2, e2, i, val) = e;\n\n            if(i &lt; 0){\n                ret.emplace_back(val, r1 - l1, r2 - l2);\n                continue;\n            }\n\n            // 0\n            int l10 = ba[i].rank(l1, 0);\n            int r10 = ba[i].rank(r1, 0);\n            int l20 = ba[i].rank(l2, 0);\n            int r20 = ba[i].rank(r2, 0);\n            if(l10&lt;r10 &amp;&amp; l20&lt;r20) que.emplace(l10, r10, l20, r20, i-1, val);\n\n            // 1\n            int l11 = nzero[i] + ba[i].rank(l1, 1);\n            int r11 = nzero[i] + ba[i].rank(r1, 1);\n            int l21 = nzero[i] + ba[i].rank(l2, 1);\n            int r21 = nzero[i] + ba[i].rank(r2, 1);\n            if(l11&lt;r11 &amp;&amp; l21&lt;r21) que.emplace(l11, r11, l21, r21, i-1, val | (1LLU&lt;&lt;i));\n        }\n\n        return ret;\n    }\n};\n</code></pre>"},{"location":"geometry/circle/","title":"Circle","text":""},{"location":"geometry/circle/#c","title":"C++","text":"<pre><code>struct V {\n    using Type = double;\n    Type x, y;\n    V(Type x = 0, Type y = 0) : x(x), y(y) {}\n\n    V &amp;operator+=(const V &amp;v) {\n        x += v.x;\n        y += v.y;\n        return *this;\n    }\n    V operator+(const V &amp;v) const { return V(*this) += v; }\n    V &amp;operator-=(const V &amp;v) {\n        x -= v.x;\n        y -= v.y;\n        return *this;\n    }\n    V operator-(const V &amp;v) const { return V(*this) -= v; }\n    V &amp;operator*=(Type s) {\n        x *= s;\n        y *= s;\n        return *this;\n    }\n    V operator*(Type s) const { return V(*this) *= s; }\n    V &amp;operator/=(Type s) {\n        x /= s;\n        y /= s;\n        return *this;\n    }\n    V operator/(Type s) const { return V(*this) /= s; }\n\n    Type dot(const V &amp;v) const { return x * v.x + y * v.y; }\n    Type norm2() const { return x * x + y * y; }\n    Type norm() const { return std::sqrt(norm2()); }\n    V &amp;rotate(Type theta) {\n        x = x * std::cos(theta) - y * std::sin(theta);\n        y = x * std::sin(theta) + y * std::cos(theta);\n        return *this;\n    }\n    V rotate90() { return V(-y, x); }\n};\n\nstruct Circle {\n    static constexpr double EPS = 1e-9;\n    V o;\n    double r;\n    Circle(V o = V(), double r = 0) : o(o), r(r) {}\n\n    std::vector&lt;V&gt; get_intersection(const Circle &amp;c) {\n        if (is_separate(c))\n            return {};\n        if (is_inside(c))\n            return {};\n\n        V v = c.o - o;\n        double d = v.norm();\n\n        // circumscribed\n        if (std::abs(d - (r + c.r)) &lt; EPS)\n            return std::vector&lt;V&gt;{v * (r / d) + o};\n        // inscribed\n        if (std::abs(d - std::abs(r - c.r)) &lt; EPS)\n            return std::vector&lt;V&gt;{v * (std::max(r, c.r) / d) + o};\n\n        // intersect\n        double x = (r * r - c.r * c.r + d * d) / (2 * d), l = std::sqrt(r * r - x * x);\n        V v1 = v * (x / d), v2 = v1.rotate90() * (l / x);\n        return std::vector&lt;V&gt;{v1 + v2 + o, v1 - v2 + o};\n    }\n\n    bool is_intersect(const Circle &amp;c) {\n        return !(is_inside(c) or is_separate(c));\n    }\n\n    bool is_inside(const V &amp;v) {\n        return (v - o).norm() &lt; r + EPS;\n    }\n\n    bool is_inside(const Circle &amp;c) {\n        V v = c.o - o;\n        double d = v.norm();\n        return d &lt; std::abs(r - c.r) + EPS;\n    }\n\n    bool is_separate(const Circle &amp;c) {\n        V v = c.o - o;\n        double d = v.norm();\n        return r + c.r &lt; d + EPS;\n    }\n};\n</code></pre>"},{"location":"geometry/circle/#example","title":"Example","text":"<ul> <li>ABC 151 F - Enclose All (C++)</li> <li>ABC 157 F - Yakiniku Optimization Problem (C++)</li> <li>ABC 181 F - Silver Woods (C++)</li> </ul>"},{"location":"geometry/convex_hull/","title":"Convex hull","text":""},{"location":"geometry/convex_hull/#c","title":"C++","text":"<pre><code>struct V {\n    using Type = double;\n    Type x, y;\n    int id;\n    V(Type x = 0, Type y = 0) : x(x), y(y) {}\n\n    V &amp;operator+=(const V &amp;v) {\n        x += v.x;\n        y += v.y;\n        return *this;\n    }\n    V operator+(const V &amp;v) const { return V(*this) += v; }\n    V &amp;operator-=(const V &amp;v) {\n        x -= v.x;\n        y -= v.y;\n        return *this;\n    }\n    V operator-(const V &amp;v) const { return V(*this) -= v; }\n    V &amp;operator*=(Type s) {\n        x *= s;\n        y *= s;\n        return *this;\n    }\n    V operator*(Type s) const { return V(*this) *= s; }\n    V &amp;operator/=(Type s) {\n        x /= s;\n        y /= s;\n        return *this;\n    }\n    V operator/(Type s) const { return V(*this) /= s; }\n\n    Type dot(const V &amp;v) const { return x * v.x + y * v.y; }\n    Type norm2() const { return x * x + y * y; }\n    Type norm() const { return std::sqrt(norm2()); }\n    V &amp;rotate(Type theta) {\n        x = x * std::cos(theta) - y * std::sin(theta);\n        y = x * std::sin(theta) + y * std::cos(theta);\n        return *this;\n    }\n    V rotate90() { return V(-y, x); }\n};\n\n// 3D cross product of OA and OB vectors, (i.e z-component of their \"2D\" cross product, but remember that it is not defined in \"2D\").\n// Returns a positive value, if OAB makes a counter-clockwise turn,\n// negative for clockwise turn, and zero if the points are collinear.\ndouble cross(const V &amp;O, const V &amp;A, const V &amp;B) {\n    return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);\n}\n\n// Returns a list of points on the convex hull in counter-clockwise order.\n// Note: the last point in the returned list is the same as the first one.\nstd::vector&lt;V&gt; convex_hull(std::vector&lt;V&gt; pt) {\n    size_t n = pt.size(), k = 0;\n    if (n &lt;= 3)\n        return pt;\n    std::vector&lt;V&gt; H(2 * n);\n\n    // Sort points lexicographically\n    std::sort(pt.begin(), pt.end(), [](V a, V b) {\n        return a.x &lt; b.x or (a.x == b.x and a.y &lt; b.y);\n    });\n\n    // Build lower hull\n    for (size_t i = 0; i &lt; n; ++i) {\n        while (k &gt;= 2 &amp;&amp; cross(H[k - 2], H[k - 1], pt[i]) &lt;= 0)\n            k--;\n        H[k++] = pt[i];\n    }\n\n    // Build upper hull\n    for (size_t i = n - 1, t = k + 1; i &gt; 0; --i) {\n        while (k &gt;= t &amp;&amp; cross(H[k - 2], H[k - 1], pt[i - 1]) &lt;= 0)\n            k--;\n        H[k++] = pt[i - 1];\n    }\n\n    H.resize(k - 1);\n    return H;\n}\n</code></pre>"},{"location":"geometry/convex_hull/#example","title":"Example","text":"<ul> <li>AGC021 B - Holes (C++)</li> </ul>"},{"location":"geometry/cross_check/","title":"Cross check","text":"<p>check if two line segment (ax, ay)-(bx, by) and (cx, cy)-(dx, dy) are cross</p>"},{"location":"geometry/cross_check/#c","title":"C++","text":"<pre><code>bool check(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy) {\n    double ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n    double tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n    double tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n    double td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n\n    return tc * td &lt; 0 &amp;&amp; ta * tb &lt; 0;\n}\n</code></pre>"},{"location":"geometry/line/","title":"Line","text":""},{"location":"geometry/line/#c","title":"C++","text":"<pre><code>struct Line {\n    // a*x + b*y + c = 0\n    long long a;\n    long long b;\n    long long c;\n\n    Line(long long a, long long b, long long c) {\n        long long g = std::gcd(a, std::gcd(b, c));\n        a /= g;\n        b /= g;\n        c /= g;\n\n        if (a &lt; 0) {\n            a *= -1;\n            b *= -1;\n            c *= -1;\n        } else if (a == 0 and b &lt; 0) {\n            b *= -1;\n            c *= -1;\n        }\n        this-&gt;a = a;\n        this-&gt;b = b;\n        this-&gt;c = c;\n    }\n\n    static Line from_point(long long x1, long long y1, long long x2, long long y2) {\n        // assume (x1, y1) != (x2, y2)\n        long long dx = x1 - x2, dy = y1 - y2;\n        return Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    bool operator==(const Line &amp;other) {\n        return a == other.a and b == other.b and c == other.c;\n    }\n};\n\ninline bool operator&lt;(const Line &amp;lhs, const Line &amp;rhs) {\n    if (lhs.a != rhs.a)\n        return lhs.a &lt; rhs.a;\n    if (lhs.b != rhs.b)\n        return lhs.b &lt; rhs.b;\n    if (lhs.c != rhs.c)\n        return lhs.c &lt; rhs.c;\n    return false;\n}\n</code></pre>"},{"location":"geometry/line/#example","title":"Example","text":"<p>ARC 173 B - Make Many Triangles (C++)</p>"},{"location":"geometry/vector/","title":"Vector","text":""},{"location":"geometry/vector/#c","title":"C++","text":"<pre><code>struct V {\n    using Type = double;\n    Type x, y;\n    V(Type x = 0, Type y = 0) : x(x), y(y) {}\n\n    V &amp;operator+=(const V &amp;v) {\n        x += v.x;\n        y += v.y;\n        return *this;\n    }\n    V operator+(const V &amp;v) const { return V(*this) += v; }\n    V &amp;operator-=(const V &amp;v) {\n        x -= v.x;\n        y -= v.y;\n        return *this;\n    }\n    V operator-(const V &amp;v) const { return V(*this) -= v; }\n    V &amp;operator*=(Type s) {\n        x *= s;\n        y *= s;\n        return *this;\n    }\n    V operator*(Type s) const { return V(*this) *= s; }\n    V &amp;operator/=(Type s) {\n        x /= s;\n        y /= s;\n        return *this;\n    }\n    V operator/(Type s) const { return V(*this) /= s; }\n\n    Type dot(const V &amp;v) const { return x * v.x + y * v.y; }\n    Type norm2() const { return x * x + y * y; }\n    Type norm() const { return std::sqrt(norm2()); }\n    V &amp;rotate(Type theta) {\n        x = x * std::cos(theta) - y * std::sin(theta);\n        y = x * std::sin(theta) + y * std::cos(theta);\n        return *this;\n    }\n    V rotate90() { return V(-y, x); }\n};\n</code></pre>"},{"location":"graph/bellman_ford/","title":"Bellman ford","text":""},{"location":"graph/bellman_ford/#c","title":"C++","text":"<pre><code>template &lt;class T = int&gt;\nstruct Graph {\n    struct Edge {\n        int from, to, id = -1;\n        T cost = 1;\n\n        Edge(int from, int to, T cost = 1, int id = -1) : from(from), to(to), cost(cost), id(id) {}\n    };\n\n    Graph(int N) : N(N) {\n        edges.resize(N);\n    }\n\n    void add_directed_edge(int from, int to, T cost = 1, int id = -1) {\n        Edge e(from, to, cost, id);\n        edges[from].push_back(e);\n    }\n\n    void add_edge(int u, int v, T cost = 1, int id = -1) {\n        add_directed_edge(u, v, cost, id);\n        add_directed_edge(v, u, cost, id);\n    }\n\n    std::vector&lt;T&gt; bellman_ford(int s = 0, T inf = 1 &lt;&lt; 30) {\n        // inf := \u30b3\u30b9\u30c8\u306e\u521d\u671f\u5024\n        std::vector&lt;T&gt; dist(N, inf);\n        dist[s] = 0;\n\n        // \u9ad8\u3005 N-1 \u56de\u306e\u30eb\u30fc\u30d7\u3067\u5168\u9802\u70b9\u306e\u6700\u77ed\u8ddd\u96e2\u304c\u6c42\u307e\u308b\n        for (int i = 0; i &lt; N - 1; i++) {\n            for (int j = 0; j &lt; N; j++) {\n                for (Edge &amp;e : edges[j]) {\n                    dist[e.to] = std::min(dist[e.to], dist[e.from] + e.cost);\n                }\n            }\n        }\n\n        return dist;\n    }\n\n    bool exists_negative_cycle(int s = 0, T inf = 1 &lt;&lt; 30) {\n        // \u8ca0\u9589\u8def\u5b58\u5728\u5224\u5b9a\n        // inf := \u30b3\u30b9\u30c8\u306e\u521d\u671f\u5024\n        std::vector&lt;T&gt; dist = bellman_ford(s, inf);\n\n        // N \u56de\u76ee\u306e\u30eb\u30fc\u30d7\u3067\u6700\u77ed\u8ddd\u96e2\u306e\u66f4\u65b0\u304c\u3042\u308c\u3070\u8ca0\u9589\u8def\u304c\u5b58\u5728\n        for (int i = 0; i &lt; N; i++) {\n            for (Edge &amp;e : edges[i]) {\n                if (dist[e.from] + e.cost &lt; dist[e.to])\n                    return true;\n            }\n        }\n\n        return false;\n    }\n\n    bool exists_reachable_negative_cycle(int s = 0, T inf = 1 &lt;&lt; 30) {\n        // \u9802\u70b9 s \u304b\u3089\u5230\u9054\u53ef\u80fd\u306a\u8ca0\u9589\u8def\u306e\u5b58\u5728\u5224\u5b9a\n        // inf := \u30b3\u30b9\u30c8\u306e\u521d\u671f\u5024\n        std::vector&lt;T&gt; dist(N, inf);\n        dist[s] = 0;\n        // \u5230\u9054\u53ef\u80fd\u30d5\u30e9\u30b0\n        std::vector&lt;int&gt; reachable(N, 0);\n        reachable[s] = 1;\n\n        // \u9ad8\u3005 N-1 \u56de\u306e\u30eb\u30fc\u30d7\u3067\u5168\u9802\u70b9\u306e\u6700\u77ed\u8ddd\u96e2\u304c\u6c42\u307e\u308b\n        for (int i = 0; i &lt; N - 1; i++) {\n            for (int j = 0; i &lt; N; j++) {\n                for (Edge &amp;e : edges[j]) {\n                    if (dist[e.from] + e.cost &lt; dist[e.to]) {\n                        dist[e.to] = dist[e.from] + e.cost;\n                        if (reachable[e.from] == 1) {\n                            reachable[e.to] = 1;\n                        }\n                    }\n                }\n            }\n        }\n\n        // N \u56de\u76ee\u306e\u30eb\u30fc\u30d7\u3067\u5230\u9054\u53ef\u80fd\u306a\u9802\u70b9\u306e\u6700\u77ed\u8ddd\u96e2\u306e\u66f4\u65b0\u304c\u3042\u308c\u3070\u8ca0\u9589\u8def\u304c\u5b58\u5728\n        for (int i = 0; i &lt; N; i++) {\n            for (Edge &amp;e : edges[i]) {\n                if (reachable[e.from] == 1 and dist[e.from] + e.cost &lt; dist[e.to])\n                    return true;\n            }\n        }\n\n        return false;\n    }\n\n  private:\n    int N;\n    std::vector&lt;std::vector&lt;Edge&gt;&gt; edges;\n};\n</code></pre>"},{"location":"graph/bellman_ford/#example","title":"Example","text":"<ul> <li>ARC173 D - Bracket Walk (C++)</li> </ul>"},{"location":"graph/dijkstra/","title":"Dijkstra","text":""},{"location":"graph/dijkstra/#c","title":"C++","text":"<pre><code>template &lt;class T = int&gt;\nstruct Graph {\n    struct Edge {\n        int from, to, id = -1;\n        T cost = 1;\n\n        Edge(int from, int to, T cost = 1, int id = -1) : from(from), to(to), cost(cost), id(id) {}\n    };\n\n    Graph(int N) : N(N) {\n        edges.resize(N);\n    }\n\n    void add_directed_edge(int from, int to, T cost = 1, int id = -1) {\n        Edge e(from, to, cost, id);\n        edges[from].push_back(e);\n    }\n\n    void add_edge(int u, int v, T cost = 1, int id = -1) {\n        add_directed_edge(u, v, cost, id);\n        add_directed_edge(v, u, cost, id);\n    }\n\n    std::vector&lt;T&gt; dijkstra(int s = 0) {\n        std::vector&lt;T&gt; dist(N, -1);\n        std::priority_queue&lt;std::pair&lt;T, int&gt;, std::vector&lt;std::pair&lt;T, int&gt;&gt;, std::greater&lt;std::pair&lt;T, int&gt;&gt;&gt; q;\n\n        auto push = [&amp;](int v, T cost) {\n            if (dist[v] &lt; 0 or cost &lt; dist[v]) {\n                dist[v] = cost;\n                q.emplace(cost, v);\n            }\n        };\n\n        push(s, 0);\n        while (!q.empty()) {\n            auto [cost, v] = q.top();\n            q.pop();\n\n            if (dist[v] &lt; cost)\n                continue;\n\n            for (Edge &amp;e : edges[v]) {\n                push(e.to, cost + e.cost);\n            }\n        }\n\n        return dist;\n    }\n\n  private:\n    int N;\n    std::vector&lt;std::vector&lt;Edge&gt;&gt; edges;\n};\n</code></pre>"},{"location":"graph/low_link/","title":"Low link","text":""},{"location":"graph/low_link/#c","title":"C++","text":"<pre><code>struct LowLink {\n    struct Edge {\n        int from, to, id = -1;\n        Edge(int from, int to, int id = -1) : from(from), to(to), id(id) {}\n    };\n\n    LowLink(int N) : N(N) {\n        edges.resize(N);\n        ord.resize(N, N);\n        low.resize(N, N);\n    }\n\n    void add_directed_edge(int u, int v, int id = -1) {\n        // assume 0-indexed\n        edges[u].emplace_back(u, v, id);\n        while (int(back_edge.size()) &lt;= id)\n            back_edge.push_back(0);\n    }\n\n    void add_edge(int u, int v, int id = -1) {\n        // assume 0-indexed\n        add_directed_edge(u, v, id);\n        add_directed_edge(v, u, id);\n    }\n\n    void build(int r = 0) {\n        low[r] = dfs(r);\n    }\n\n    bool is_bridge(int u, int v) {\n        // assume existing edge (u, v)\n        if (ord[u] &gt; ord[v])\n            std::swap(u, v);\n        return low[v] &gt; ord[u];\n    }\n\n    bool is_articulation_point(int v) {\n        if (ord[v] == 0) {\n            return int(edges[v].size()) &gt; 1;\n        }\n        for (Edge &amp;edge : edges[v]) {\n            int to = edge.to;\n            if (ord[to] &lt; ord[v])\n                continue;\n            if (is_back_edge(edge))\n                continue;\n            if (low[to] &gt;= ord[v])\n                return true;\n        }\n        return false;\n    }\n\n  private:\n    int N, cnt = 0;\n    std::vector&lt;std::vector&lt;Edge&gt;&gt; edges;\n    std::vector&lt;int&gt; ord, low, back_edge;\n\n    int dfs(int v = 0, int par = -1) {\n        if (low[v] &lt; N)\n            return low[v];\n\n        ord[v] = cnt++;\n        low[v] = ord[v];\n\n        for (Edge &amp;edge : edges[v]) {\n            int to = edge.to;\n            if (to == par)\n                continue;\n            if (ord[v] &gt; ord[to]) {\n                low[v] = std::min(low[v], ord[to]);\n                back_edge[edge.id] = 1;\n                continue;\n            }\n            low[v] = std::min(low[v], dfs(to, v));\n        }\n\n        return low[v];\n    }\n\n    bool is_back_edge(Edge &amp;edge) {\n        return back_edge[edge.id] == 1;\n    }\n};\n</code></pre>"},{"location":"graph/low_link/#example","title":"Example","text":"<ul> <li>ABC334 G - Christmas Color Grid 2 (C++)</li> </ul>"},{"location":"heuristic/beam_search/","title":"Beam search","text":""},{"location":"heuristic/beam_search/#rust","title":"Rust","text":"<pre><code>use beam_search::beam_search;\nuse domain::State;\nuse problem_io::Input;\n\nconst TURN: usize = 49;\nconst BEAM_WIDTH: usize = 200;\n\nfn main() {\n    let input = Input::new();\n    let state = State::new(input.clone());\n\n    let mut solution = beam_search(state, TURN, BEAM_WIDTH);\n}\n\npub mod problem_io {\n    use proconio::input;\n\n    #[derive(Clone)]\n    pub struct Input {}\n\n    impl Input {\n        pub fn new() -&gt; Self {\n            todo!();\n        }\n    }\n}\n\npub mod domain {\n    use super::problem_io::Input;\n\n    pub type Score = f64;\n    pub type Action = Option&lt;()&gt;;\n\n    #[derive(Clone)]\n    pub struct State {}\n\n    impl State {\n        /// \u521d\u671f\u72b6\u614b\u306e\u751f\u6210\n        pub fn new(input: Input) -&gt; Self {\n            todo!();\n        }\n\n        pub fn eval(&amp;self) -&gt; Score {\n            todo!();\n        }\n        pub fn hash(&amp;self) -&gt; u64 {\n            todo!();\n        }\n\n        /// \u30b9\u30b3\u30a2\u3068\u30cf\u30c3\u30b7\u30e5\u306e\u5dee\u5206\u8a08\u7b97\n        /// \u72b6\u614b\u306f\u66f4\u65b0\u3057\u306a\u3044\n        pub fn try_apply(&amp;mut self, op: Action, _score: Score, _hash: u64) -&gt; (Score, u64) {\n            todo!();\n        }\n\n        /// \u72b6\u614b\u3092\u66f4\u65b0\u3059\u308b\n        /// \u5143\u306e\u72b6\u614b\u306b\u623b\u3059\u305f\u3081\u306e\u60c5\u5831\u3092\u8fd4\u3059\n        pub fn apply(&amp;mut self, op: Action) -&gt; Action {\n            todo!();\n        }\n\n        /// apply\u304b\u3089\u8fd4\u3055\u308c\u305f\u60c5\u5831\u3092\u3082\u3068\u306b\u72b6\u614b\u3092\u5143\u306b\u623b\u3059\n        pub fn rollback(&amp;mut self, backup: Action) {\n            todo!();\n        }\n\n        /// \u53ef\u80fd\u306a\u64cd\u4f5c\u306e\u5019\u88dc\u3092\u751f\u6210\u3059\u308b\n        pub fn generate_op(&amp;self) -&gt; Vec&lt;Action&gt; {\n            todo!();\n        }\n    }\n}\n\npub mod beam_search {\n    use super::domain::{Action, Score, State};\n    use std::cell::UnsafeCell;\n    use std::rc::*;\n\n    struct Candidate {\n        op: Action,\n        parent: Rc&lt;Node&gt;,\n        score: Score,\n        hash: u64,\n        p: usize, // \u512a\u5148\u5ea6(\u8907\u6570\u3082\u305f\u305b\u305f\u307b\u3046\u304c\u826f\u3044\u5834\u5408\u304c\u3042\u308b\u304b\u3082\u3057\u308c\u306a\u3044\u3002)\n    }\n\n    struct Node {\n        parent: Option&lt;(Action, Rc&lt;Node&gt;)&gt;, // \u64cd\u4f5c\u3001\u89aa\u3078\u306e\u53c2\u7167\n        // \u901f\u5ea6\u306e\u305f\u3081\u306bUnsafeCell\u3092\u4f7f\u3063\u3066\u3044\u308b\u304cRefCell\u306e\u307b\u3046\u304c\u5b89\u5168\n        child: UnsafeCell&lt;Vec&lt;(Action, Weak&lt;Node&gt;)&gt;&gt;, // \u64cd\u4f5c\u3001\u5b50\u3078\u306e\u53c2\u7167\n        score: Score,\n        hash: u64,\n    }\n\n    // \u591a\u30b9\u30bf\u30fc\u30c8\u7528\u306b\u69cb\u9020\u4f53\u306b\u307e\u3068\u3081\u3066\u304a\u304f\u3068\u697d\n    struct Tree {\n        state: State,\n        node: Rc&lt;Node&gt;,\n    }\n\n    impl Tree {\n        // \u6ce8\u610f: depth\u306f\u6df1\u304f\u306a\u3063\u3066\u3044\u304f\u3054\u3068\u306b-1\u3055\u308c\u3066\u3044\u304f\n        fn dfs(&amp;mut self, next_states: &amp;mut Vec&lt;Candidate&gt;, p: &amp;mut usize, depth: usize) {\n            if depth == 0 {\n                let score = self.node.score;\n                let hash = self.node.hash;\n\n                // \u691c\u7b97\n                // assert_eq!(score, self.state.eval());\n                // assert_eq!(hash, self.state.hash());\n\n                // \u6b21\u306e\u64cd\u4f5c\u3092\u5217\u6319\n                for op in self.state.generate_op() {\n                    let (next_score, next_hash) = self.state.try_apply(op, score, hash);\n                    next_states.push(Candidate {\n                        op,\n                        parent: self.node.clone(),\n                        score: next_score,\n                        hash: next_hash,\n                        p: *p,\n                    });\n                    *p += 1;\n                }\n            } else {\n                let node = self.node.clone();\n                let child = unsafe { &amp;mut *node.child.get() };\n                // \u6709\u52b9\u306a\u5b50\u3060\u3051\u306b\u3059\u308b\n                child.retain(|(_, x)| x.upgrade().is_some());\n\n                for (op, ptr) in child {\n                    self.node = ptr.upgrade().unwrap();\n                    let backup = self.state.apply(*op);\n                    self.dfs(next_states, p, depth - 1);\n\n                    self.state.rollback(backup);\n                }\n\n                self.node = node.clone();\n            }\n        }\n    }\n\n    pub fn beam_search(init_state: State, turn: usize, beam_width: usize) -&gt; Vec&lt;Action&gt; {\n        let mut tree = {\n            let score = init_state.eval();\n            let hash = init_state.hash();\n            Tree {\n                state: init_state,\n                node: Rc::new(Node {\n                    parent: None,\n                    child: UnsafeCell::new(vec![]),\n                    score,\n                    hash,\n                }),\n            }\n        };\n\n        let mut cur_beam = vec![];\n        let mut next_states = vec![];\n\n        let mut set = rustc_hash::FxHashSet::default();\n\n        for depth in 0..turn {\n            next_states.clear();\n            tree.dfs(&amp;mut next_states, &amp;mut 0, depth);\n\n            if depth + 1 != turn {\n                // \u4e0a\u4f4dM\u500b\u3092\u6b8b\u3059\n                if next_states.len() &gt; beam_width {\n                    next_states.select_nth_unstable_by(\n                        beam_width,\n                        |Candidate {\n                             score: score1,\n                             p: p1,\n                             ..\n                         },\n                         Candidate {\n                             score: score2,\n                             p: p2,\n                             ..\n                         }| {\n                            (*score1, *p1)\n                                .partial_cmp(&amp;(*score2, *p2))\n                                .unwrap()\n                                .reverse()\n                        },\n                    );\n                    next_states.truncate(beam_width);\n                }\n\n                cur_beam.clear();\n                set.clear();\n                for Candidate {\n                    op,\n                    parent,\n                    score,\n                    hash,\n                    ..\n                } in &amp;next_states\n                {\n                    // \u91cd\u8907\u9664\u53bb\n                    if set.insert(*hash) {\n                        let child = unsafe { &amp;mut *parent.child.get() };\n                        let child_ptr = Rc::new(Node {\n                            parent: Some((*op, parent.clone())),\n                            child: UnsafeCell::new(vec![]),\n                            hash: *hash,\n                            score: *score,\n                        });\n                        cur_beam.push(child_ptr.clone());\n                        child.push((*op, Rc::downgrade(&amp;child_ptr)));\n                    }\n                }\n            }\n        }\n\n        // \u6700\u826f\u306e\u72b6\u614b\u3092\u9078\u629e\n        let Candidate {\n            op,\n            parent: mut ptr,\n            score,\n            ..\n        } = next_states\n            .into_iter()\n            .max_by(\n                |Candidate { score: score1, .. }, Candidate { score: score2, .. }| {\n                    (*score1).partial_cmp(score2).unwrap()\n                },\n            )\n            .unwrap();\n\n        let mut ret = vec![op];\n        eprintln!(\"score: {}\", score);\n\n        // \u64cd\u4f5c\u306e\u5fa9\u5143\n        while let Some((op, parent)) = ptr.parent.clone() {\n            ret.push(op);\n            ptr = parent.clone();\n        }\n\n        ret.reverse();\n        ret\n    }\n}\n\npub mod rand_generator {\n    use num_traits::PrimInt;\n    use rand::{seq::SliceRandom, Rng};\n    use rand_chacha::{rand_core::SeedableRng, ChaCha20Rng};\n    use rand_distr::{Distribution, Normal};\n\n    pub struct RandomGenerator {\n        rng: ChaCha20Rng,\n    }\n\n    impl RandomGenerator {\n        pub fn new(seed: u64) -&gt; Self {\n            Self { rng: get_rng(seed) }\n        }\n\n        pub fn gen_normal(&amp;mut self, mean: f64, std: f64) -&gt; f64 {\n            let normal_dist = Normal::&lt;f64&gt;::new(mean, std).unwrap();\n            normal_dist.sample(&amp;mut self.rng)\n        }\n\n        pub fn gen_range&lt;T: PrimInt&gt;(&amp;mut self, low: i64, high: i64, equal: bool) -&gt; T {\n            if equal {\n                T::from(self.rng.gen_range(low..=high)).unwrap()\n            } else {\n                T::from(self.rng.gen_range(low..high)).unwrap()\n            }\n        }\n\n        pub fn gen_bool(&amp;mut self, prob: f64) -&gt; bool {\n            self.rng.gen_bool(prob.clamp(0.0, 1.0))\n        }\n\n        pub fn gen_permutation(&amp;mut self, n: usize) -&gt; Vec&lt;usize&gt; {\n            let mut permutation: Vec&lt;usize&gt; = (1..=n).collect();\n            permutation.shuffle(&amp;mut self.rng);\n            permutation\n        }\n\n        pub fn shuffle&lt;T&gt;(&amp;mut self, v: &amp;mut Vec&lt;T&gt;) {\n            v.shuffle(&amp;mut self.rng);\n        }\n    }\n\n    fn get_rng(seed: u64) -&gt; ChaCha20Rng {\n        ChaCha20Rng::seed_from_u64(seed)\n    }\n}\n</code></pre>"},{"location":"heuristic/simulated_annealing/","title":"Simulated annealing","text":""},{"location":"heuristic/simulated_annealing/#rust","title":"Rust","text":"<pre><code>fn main() {\n    let input = problem_io::Input::new();\n    let state = domain::State::new(input);\n    let scheduler = simulated_annealing::Scheduler::new(T_START, T_FINAL, T_LIMIT);\n\n    let best_state = simulated_annealing::simulated_annealing(state, scheduler);\n}\n\npub mod problem_io {\n    use proconio::input;\n\n    pub struct Input {}\n\n    impl Input {\n        pub fn new() -&gt; Self {\n            todo!();\n        }\n    }\n}\n\npub mod domain {\n    use super::problem_io::Input;\n\n    pub type Score = u128;\n\n    #[derive(Clone)]\n    pub struct State {\n        score: Score,\n        last_op: Vec&lt;()&gt;,\n    }\n\n    impl State {\n        pub fn new(input: Input) -&gt; Self {\n            todo!();\n        }\n\n        pub fn move_to_neighbor(&amp;mut self) {}\n\n        pub fn eval(&amp;self) -&gt; Score {\n            self.score\n        }\n\n        pub fn rollback(&amp;mut self) {}\n    }\n}\n\npub mod simulated_annealing {\n    use super::domain::{Score, State};\n    use super::rand_generator::RandomGenerator;\n    use super::utils::Timer;\n\n    type Probability = f64;\n    type Temperature = f64;\n    type Time = f64;\n\n    pub struct Scheduler {\n        t_start: Temperature,\n        t_final: Temperature,\n        time_limit: Time,\n        timer: Timer,\n        rng: RandomGenerator,\n        complete: bool,\n    }\n\n    impl Scheduler {\n        pub fn new(t_start: Temperature, t_final: Temperature, time_limit: Time) -&gt; Self {\n            let timer = Timer::new();\n            let rng = RandomGenerator::new(998244353);\n            let complete: bool = false;\n\n            Self {\n                t_start,\n                t_final,\n                time_limit,\n                timer,\n                rng,\n                complete,\n            }\n        }\n\n        /// \u6642\u9593\u8a08\u6e2c\u958b\u59cb\n        pub fn start(&amp;mut self) {\n            self.timer.reset();\n        }\n\n        /// \u7d4c\u904e\u6642\u9593\u53d6\u5f97\n        pub fn get_elapsed_time(&amp;mut self) -&gt; Time {\n            self.timer.get_epalsed_time()\n        }\n\n        /// time_elapsed\u79d2\u7d4c\u904e\u3057\u305f\u3068\u304d\u306e\u6e29\u5ea6\u3092\u8a08\u7b97\u3059\u308b\n        fn get_temperature(&amp;self, time_elapsed: Time) -&gt; Temperature {\n            let power: f64 = time_elapsed / self.time_limit;\n            let temp: Temperature = self.t_start * (self.t_final / self.t_start).powf(power);\n            temp\n        }\n\n        /// \u9077\u79fb\u78ba\u7387\u3092\u8a08\u7b97\u3059\u308b\n        fn probability(\n            &amp;self,\n            temp: Temperature,\n            cur_score: Score,\n            new_score: Score,\n        ) -&gt; Probability {\n            // \u6700\u5c0f\u5316\n            Probability::exp((cur_score as Temperature - new_score as Temperature) / temp).min(1.0)\n            // \u6700\u5927\u5316\n            // Probability::exp((new_score as Temperature - cur_score as Temperature) / temp).min(1.0)\n        }\n\n        /// \u9077\u79fb\u3059\u308b\u304b\u3069\u3046\u304b\u306e\u5224\u5b9a\n        fn acceptance(&amp;mut self, prob: Probability) -&gt; bool {\n            // dbg!(prob);\n            self.rng.gen_bool(prob)\n        }\n\n        /// time_limit\u79d2\u7d4c\u904e\u3057\u305f\u304b\u3069\u3046\u304b\n        fn is_complete(&amp;self) -&gt; bool {\n            self.complete\n        }\n    }\n\n    pub fn simulated_annealing(mut state: State, mut scheduler: Scheduler) -&gt; State {\n        let mut num_loops: usize = 0;\n        let mut num_updates: usize = 0;\n        let mut time_elapsed: Time;\n        let mut temp: Temperature = scheduler.t_start;\n        let mut best_score: Score = state.eval();\n        let mut best_state: State = state.clone();\n\n        scheduler.start();\n        loop {\n            if num_loops % 100 == 0 {\n                time_elapsed = scheduler.get_elapsed_time();\n                temp = scheduler.get_temperature(time_elapsed);\n\n                if scheduler.is_complete() {\n                    break;\n                }\n            }\n\n            state.move_to_neighbor();\n            let new_score: Score = state.eval();\n            let prob: Probability = scheduler.probability(temp, best_score, new_score);\n            if scheduler.acceptance(prob) {\n                best_score = new_score;\n                best_state = state.clone();\n                num_updates += 1;\n            } else {\n                state.rollback();\n            }\n            num_loops += 1;\n        }\n\n        dbg!(num_loops);\n        dbg!(num_updates);\n        dbg!(best_score);\n        best_state\n    }\n}\n\npub mod rand_generator {\n    use num_traits::PrimInt;\n    use rand::{seq::SliceRandom, Rng};\n    use rand_chacha::{rand_core::SeedableRng, ChaCha20Rng};\n    use rand_distr::{Distribution, Normal};\n\n    pub struct RandomGenerator {\n        rng: ChaCha20Rng,\n    }\n\n    impl RandomGenerator {\n        pub fn new(seed: u64) -&gt; Self {\n            Self { rng: get_rng(seed) }\n        }\n\n        pub fn gen_normal(&amp;mut self, mean: f64, std: f64) -&gt; f64 {\n            let normal_dist = Normal::&lt;f64&gt;::new(mean, std).unwrap();\n            normal_dist.sample(&amp;mut self.rng)\n        }\n\n        pub fn gen_range&lt;T: PrimInt&gt;(&amp;mut self, low: i64, high: i64, equal: bool) -&gt; T {\n            if equal {\n                T::from(self.rng.gen_range(low..=high)).unwrap()\n            } else {\n                T::from(self.rng.gen_range(low..high)).unwrap()\n            }\n        }\n\n        pub fn gen_bool(&amp;mut self, prob: f64) -&gt; bool {\n            self.rng.gen_bool(prob.clamp(0.0, 1.0))\n        }\n\n        pub fn gen_permutation(&amp;mut self, n: usize) -&gt; Vec&lt;usize&gt; {\n            let mut permutation: Vec&lt;usize&gt; = (1..=n).collect();\n            permutation.shuffle(&amp;mut self.rng);\n            permutation\n        }\n\n        pub fn shuffle&lt;T&gt;(&amp;mut self, v: &amp;mut Vec&lt;T&gt;) {\n            v.shuffle(&amp;mut self.rng);\n        }\n    }\n\n    fn get_rng(seed: u64) -&gt; ChaCha20Rng {\n        ChaCha20Rng::seed_from_u64(seed)\n    }\n}\n\npub mod utils {\n    pub struct Timer {\n        start_time: f64,\n    }\n\n    impl Timer {\n        pub fn new() -&gt; Self {\n            let start_time = Self::get_current_time();\n            Self { start_time }\n        }\n\n        /// \u73fe\u5728\u306e\u6642\u523b[sec]\u3092\u53d6\u5f97\u3059\u308b\n        fn get_current_time() -&gt; f64 {\n            let t = std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap(); // 1970-01-01 00:00:00 \u304b\u3089\u306e\u6642\u9593\u304c\u53d6\u5f97\u3067\u304d\u308b (\u5358\u4f4d\u4e0d\u660e)\n            t.as_secs() as f64 + t.subsec_nanos() as f64 * 1e-9\n        }\n\n        /// \u73fe\u5728\u306e\u7d4c\u904e\u6642\u9593[sec]\u3092\u53d6\u5f97\u3059\u308b\n        pub fn get_epalsed_time(&amp;self) -&gt; f64 {\n            let current_time = Self::get_current_time();\n            current_time - self.start_time\n        }\n\n        /// timer \u3092\u30ea\u30bb\u30c3\u30c8\u3059\u308b\n        pub fn reset(&amp;mut self) {\n            self.start_time = Self::get_current_time();\n        }\n    }\n}\n</code></pre>"},{"location":"heuristic/timer/","title":"Timer","text":""},{"location":"heuristic/timer/#rust","title":"Rust","text":"<pre><code>pub mod utils {\n    pub struct Timer {\n        start_time: f64,\n    }\n\n    impl Timer {\n        pub fn new() -&gt; Self {\n            let start_time = Self::get_current_time();\n            Self { start_time }\n        }\n\n        /// \u73fe\u5728\u306e\u6642\u523b[sec]\u3092\u53d6\u5f97\u3059\u308b\n        fn get_current_time() -&gt; f64 {\n            let t = std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap(); // 1970-01-01 00:00:00 \u304b\u3089\u306e\u6642\u9593\u304c\u53d6\u5f97\u3067\u304d\u308b (\u5358\u4f4d\u4e0d\u660e)\n            t.as_secs() as f64 + t.subsec_nanos() as f64 * 1e-9\n        }\n\n        /// \u73fe\u5728\u306e\u7d4c\u904e\u6642\u9593[sec]\u3092\u53d6\u5f97\u3059\u308b\n        pub fn get_epalsed_time(&amp;self) -&gt; f64 {\n            let current_time = Self::get_current_time();\n            current_time - self.start_time\n        }\n\n        /// timer \u3092\u30ea\u30bb\u30c3\u30c8\u3059\u308b\n        pub fn reset(&amp;mut self) {\n            self.start_time = Self::get_current_time();\n        }\n    }\n}\n</code></pre>"},{"location":"math/divisor/","title":"Divisor","text":""},{"location":"math/divisor/#c","title":"C++","text":"<pre><code>std::vector&lt;long long&gt; make_divisors(long long n){\n    std::vector&lt;long long&gt; divisors;\n    for(long long i=1; i*i&lt;=n; i++){\n        if(n%i == 0){\n            divisors.push_back(i);\n            if(i*i != n) divisors.push_back(n/i);\n        }\n    }\n    // std::sort(divisors.begin(), divisors.end());\n    return divisors;\n}\n</code></pre>"},{"location":"math/eratosthenes/","title":"Eratosthenes","text":""},{"location":"math/eratosthenes/#c","title":"C++","text":"<pre><code>struct SieveEratosthenes{\n    std::vector&lt;int&gt; min_fact;\n\n    SieveEratosthenes(int N){\n        _build(N);\n    }\n\n    void _build(int N){\n        min_fact.resize(N+1);\n        for(int i=0; i&lt;=N; i++) min_fact[i] = i;\n\n        min_fact[0] = min_fact[1] = -1;\n\n        for(int i=2; i*i&lt;=N; i++){\n            for(int j=i*i; j&lt;=N; j+=i){\n                if(i &lt; min_fact[j])\n                    min_fact[j] = i;\n            }\n        }\n    }\n\n    bool is_prime(int x){\n        return min_fact[x] == x;\n    }\n\n    std::vector&lt;std::pair&lt;int,int&gt;&gt; factorize(int x){\n        std::vector&lt;std::pair&lt;int,int&gt;&gt; ret;\n        while(x&gt;1){\n            if(ret.empty() || ret.back().first != min_fact[x])\n                ret.emplace_back(min_fact[x], 1);\n            else\n                ret.back().second++;\n\n            x /= min_fact[x];\n        }\n\n        return ret;\n    }\n};\n</code></pre>"},{"location":"math/ext_euclid/","title":"Ext euclid","text":""},{"location":"math/ext_euclid/#c","title":"C++","text":"<pre><code>// ax + by = gcd(a, b) \u3092\u6e80\u305f\u3059 (x, y)\nstd::pair&lt;long long, long long&gt; ext_euclid(long long a, long long b) {\n    if (b == 0)\n        return make_pair(1, 0);\n    long long x, y;\n    tie(y, x) = ext_euclid(b, a % b);\n    y -= a / b * x;\n    return make_pair(x, y);\n}}\n</code></pre>"},{"location":"math/factorial/","title":"Factorial","text":""},{"location":"math/factorial/#c","title":"c++","text":"<pre><code>template&lt;long long mod=1000000007&gt;\nstruct modint {\n    long long x;\n    modint(long long x=0):x((x%mod+mod)%mod){}\n    long long val(){\n        return x;\n    }\n    modint&lt;mod&gt; operator-() const { return modint(-x);}\n    modint&lt;mod&gt;&amp; operator+=(const modint a) {\n        if ((x += a.x) &gt;= mod) x -= mod;\n        return *this;\n    }\n    modint&lt;mod&gt;&amp; operator-=(const modint a) {\n        if ((x += mod-a.x) &gt;= mod) x -= mod;\n        return *this;\n    }\n    modint&lt;mod&gt;&amp; operator*=(const modint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    modint&lt;mod&gt; operator+(const modint a) const {\n        modint&lt;mod&gt; res(*this);\n        return res+=a;\n    }\n    modint&lt;mod&gt; operator-(const modint a) const {\n        modint&lt;mod&gt; res(*this);\n        return res-=a;\n    }\n    modint&lt;mod&gt; operator*(const modint a) const {\n        modint&lt;mod&gt; res(*this);\n        return res*=a;\n    }\n    modint&lt;mod&gt; pow(long long t) const {\n        if (!t) return 1;\n        modint&lt;mod&gt; a = pow(t&gt;&gt;1);\n        a *= a;\n        if (t&amp;1) a *= *this;\n        return a;\n    }\n\n    // must be gcd(x,mod)==1\n    modint&lt;mod&gt; inv() const {\n        // a^{-1} = 1/a mod p (\u62e1\u5f35Euclid\u306e\u4e92\u9664\u6cd5)\n        long long b = mod, u = 1, v = 0, z = x;\n        while(b){\n            long long t = z / b;\n            z -= t * b; swap(z, b);\n            u -= t * v; swap(u, v);\n        }\n        u %= mod;\n        if (u &lt; 0) u += mod;\n        return modint&lt;mod&gt;(u);\n    }\n\n    //modint inv() const {\n    //    return pow(mod-2);\n    //}\n\n    modint&lt;mod&gt;&amp; operator/=(const modint a) {\n        return (*this) *= a.inv();\n    }\n    modint&lt;mod&gt; operator/(const modint a) const {\n        modint&lt;mod&gt; res(*this);\n        return res/=a;\n    }\n};\n\ntemplate&lt;long long mod=1000000007&gt;\nstruct Factorial{\n\n    vector&lt;modint&lt;mod&gt;&gt; fact, ifact;\n\n    Factorial(int N): fact(N+1), ifact(N+1) {\n        assert(N &lt; MOD);\n\n        fact[0] = 1;\n        for(int i=0; i&lt;N; i++) fact[i+1] = fact[i] * (i+1);\n\n        ifact[N] = fact[N].inv();\n        for(int i=N; i&gt;0; i--) ifact[i-1] = ifact[i] * i;\n    }\n\n    modint&lt;mod&gt; C(int n, int k){\n        if (k &lt; 0 || k &gt; n) return 0;\n        return fact[n]*ifact[k]*ifact[n-k];\n    }\n\n    modint&lt;mod&gt; P(int n, int k){\n        if (k &lt; 0 || k &gt; n) return 0;\n        return fact[n]*ifact[n-k];\n    }\n\n    modint&lt;mod&gt; inv(int n){\n        assert(n&gt;0);\n        return fact[n-1]*ifact[n];\n    }\n};\nusing mint = modint&lt;998244353&gt;;\nusing Fact = Factorial&lt;998244353&gt;;\n</code></pre>"},{"location":"math/factorial_system/","title":"Factorial system","text":""},{"location":"math/factorial_system/#c","title":"C++","text":"<pre><code>template &lt;class T = int&gt; struct FenwickTree {\n  public:\n    FenwickTree() : _n(0) {}\n    explicit FenwickTree(int n) : _n(n), data(n) {}\n\n    void add(int p, T x) {\n        p++;\n        while (p &lt;= _n) {\n            data[p - 1] += x;\n            p += p &amp; -p;\n        }\n    }\n\n    T sum(int l, int r) {\n        return sum(r) - sum(l);\n    }\n\n  private:\n    int _n;\n    std::vector&lt;T&gt; data;\n\n    T sum(int r) {\n        T s = 0;\n        while (r &gt; 0) {\n            s += data[r - 1];\n            r -= r &amp; -r;\n        }\n        return s;\n    }\n};\n\nstruct FactorialSystem {\n    std::vector&lt;int&gt; a;\n\n    FactorialSystem(std::vector&lt;int&gt; &amp;a) {\n        build(a);\n    }\n    FactorialSystem(int N, bool zero = true) {\n        // if zero then 0 \u306e\u9577\u3055 N \u306e\u968e\u4e57\u9032\u6cd5\u8868\u8a18 else N! \u306e\u968e\u4e57\u9032\u6cd5\u8868\u8a18\n        if (zero) {\n            std::vector&lt;int&gt; a(N, 0);\n            build(a);\n        } else {\n            std::vector&lt;int&gt; a(N + 1, 0);\n            a[N] = 1;\n            build(a);\n        }\n    }\n    FactorialSystem(uint64_t X) {\n        // X \u306e\u968e\u4e57\u9032\u6cd5\u8868\u8a18\n        std::vector&lt;int&gt; a;\n        std::uint64_t p = 1;\n\n        while(X) {\n            int ai = X % p;\n            X /= p++;\n            a.push_back(ai);\n        }\n\n        build(a);\n    }\n\n    std::vector&lt;int&gt; to_permutation(bool remove_leading_zero = false) {\n        int N = size(), threshold = -1;\n        std::vector&lt;int&gt; p(N);\n        FenwickTree fenwick_tree(N);\n\n        for(int i = N - 1; i &gt;= 0; i--) {\n            int ok = 0, ng = N;\n            while(ng - ok &gt; 1) {\n                int m = (ok + ng) / 2;\n                if(m - fenwick_tree.sum(0, m) &lt;= a[i])\n                    ok = m;\n                else\n                    ng = m;\n            }\n\n            p[N - 1 - i] = ok;\n            fenwick_tree.add(ok, 1);\n        }\n        return p;\n    }\n\n    FactorialSystem&amp; operator+=(FactorialSystem &amp;fs) {\n        int N = fs.size(), kuriage = 0;\n        for(int i = 0; i &lt; N; i++) {\n            if(a.size() &lt; i + 1) {\n                a.push_back(0);\n            }\n            a[i] += fs.a[i] + kuriage;\n            kuriage = a[i] / (i + 1);\n            a[i] %= i + 1;\n        }\n\n        int n = N;\n        while(kuriage &gt; 0) {\n            if(a.size() &lt; n + 1) {\n                a.push_back(0);\n            }\n            a[n] += kuriage;\n            kuriage = a[n] / (n + 1);\n            a[n] %= n + 1;\n            n++;\n        }\n        return *this;\n    }\n    FactorialSystem&amp; operator+=(const std::uint64_t x) {\n        FactorialSystem fs(x);\n        *this += fs;\n        return *this;\n    }\n    FactorialSystem operator+(FactorialSystem &amp;fs) {\n        FactorialSystem res(*this);\n        return res += fs;\n    }\n    FactorialSystem operator+(const std::uint64_t x) {\n        FactorialSystem res(*this);\n        return res += x;\n    }\n\n    FactorialSystem&amp; operator-=(FactorialSystem &amp;fs) {\n        // assume this &gt;= fs\n        int N = fs.size();\n        for(int i = N - 1; i &gt;= 0; i--) {\n            if (a[i] &lt; fs.a[i]) {\n                int pos = i + 1;\n                while(a[pos] == 0)\n                    pos++;\n                for(int j = pos; j &gt; i; j--) {\n                    a[j]--;\n                    a[j - 1] += j;\n                }\n            }\n            a[i] -= fs.a[i];\n        }\n\n        return *this;\n    }\n    FactorialSystem&amp; operator-=(const std::uint64_t x) {\n        // assume this &gt;= x\n        FactorialSystem fs(x);\n        *this -= fs;\n        return *this;\n    }\n    FactorialSystem operator-(FactorialSystem &amp;fs) {\n        FactorialSystem res(*this);\n        return res -= fs;\n    }\n    FactorialSystem operator-(const std::uint64_t x) {\n        FactorialSystem res(*this);\n        return res -= x;\n    }\n\n    FactorialSystem&amp; operator*=(const int x) {\n        int N = size();\n        std::uint64_t kuriage = 0;\n        for(int i = 0; i &lt; N; i++) {\n            std::uint64_t sum = 1ULL * a[i] * x + kuriage;\n            a[i] = sum % (i + 1);\n            kuriage = sum / (i + 1);\n        }\n\n        int n = N;\n        while(kuriage &gt; 0) {\n            a.push_back(0);\n            a[n] = kuriage % (n + 1);\n            kuriage /= (n + 1);\n            n++;\n        }\n\n        return *this;\n    }\n    FactorialSystem operator*(const int x) {\n        FactorialSystem res(*this);\n        return res *= x;\n    }\n\n    FactorialSystem&amp; operator/=(const int x) {\n        // \u968e\u4e57\u9032\u6cd5\u306e\u5272\u308a\u7b97 O(N)\n        int N = size();\n        std::uint64_t kuriage = 0;\n        for(int i = N - 1; i &gt;= 0; i--) {\n            std::uint64_t sum = kuriage + a[i];\n            if(kuriage + a[i] &lt; x) {\n                kuriage = sum * i;\n                a[i] = 0;\n                continue;\n            }\n            a[i] = sum / x;\n            kuriage = (sum % x) * i;\n        }\n\n        return *this;\n    }\n    FactorialSystem operator/(const int x) {\n        FactorialSystem res(*this);\n        return res /= x;\n    }\n\n    size_t size() {\n        return a.size();\n    }\n\n    void truncate(int N) {\n        while(a.size() &gt; N and a.back() == 0)\n            a.pop_back();\n    }\n\n    void print() {\n        for(int i = 0; i &lt; size(); i ++) {\n            std::cout &lt;&lt; a[i] &lt;&lt; \" \\n\"[i == size() - 1];\n        }\n    }\n\n  private:\n    void build(std::vector&lt;int&gt; &amp;a_) {\n        a = a_;\n    }\n};\n</code></pre>"},{"location":"math/factorial_system/#example","title":"Example","text":"<ul> <li>ARC047 C - N!\u00f7K\u756a\u76ee\u306e\u5358\u8a9e (C++)</li> </ul>"},{"location":"math/factorize/","title":"Factorize","text":""},{"location":"math/factorize/#c","title":"C++","text":"<pre><code>std::vector&lt;std::pair&lt;long long, int&gt;&gt; factorize(long long n){\n    std::vector&lt;std::pair&lt;long long, int&gt;&gt; res;\n\n    if(n%2 == 0){\n        res.emplace_back(2,0);\n        while(n%2 == 0){\n            n /= 2;\n            res.back().second++;\n        }\n    }\n\n    for(long long  i=3; i*i&lt;=n; i+=2){\n        if(n%i) continue;\n        res.emplace_back(i,0);\n        while(n%i == 0){\n            n /= i;\n            res.back().second++;\n        }\n    }\n    if(n != 1) res.emplace_back(n,1);\n    return res;\n}\n</code></pre>"},{"location":"math/factorize/#rust","title":"Rust","text":"<pre><code>fn factorize(mut x: u64) -&gt; Vec&lt;(u64, u64)&gt; {\n    let mut fact = vec![];\n    let sqrt = x.sqrt();\n\n    let mut divide = |p| {\n        let mut count = 0;\n        while x % p == 0 {\n            x /= p;\n            count += 1;\n        }\n        if count &gt; 0 {\n            fact.push((p, count));\n        }\n    };\n\n    divide(2);\n\n    for p in (3..=sqrt).step_by(2) {\n        divide(p);\n    }\n\n    if x &gt; 1 {\n        fact.push((x, 1));\n    }\n\n    fact\n}\n</code></pre>"},{"location":"math/fft/","title":"Fft","text":""},{"location":"math/fft/#c","title":"c++","text":"<pre><code>long long mod_inv(long long a, long long mod){\n    // a^{-1} = 1/a mod p (\u62e1\u5f35Euclid\u306e\u4e92\u9664\u6cd5)\n    long long b = mod, u = 1, v = 0;\n    while (b) {\n        long long t = a / b;\n        a -= t * b; swap(a, b);\n        u -= t * v; swap(u, v);\n    }\n    u %= mod;\n    if (u &lt; 0) u += mod;\n    return u;\n}\nlong long mod_pow(long long a, long long n, long long mod){\n    long long ret = 1;\n    long long p = a % mod;\n    while(n){\n        if(n&amp;1) ret = ret * p % mod;\n        p = p * p % mod;\n        n &gt;&gt;= 1;\n    }\n    return ret;\n}\n\n\ntemplate&lt;int mod, int primitive_root&gt;\nclass NTT {\npublic:\n    int get_mod() const { return mod; }\n    void _ntt(vector&lt;long long&gt;&amp; a, int sign) {\n        const int n = a.size();\n        assert((n ^ (n&amp;-n)) == 0); //n = 2^k\n\n        const int g = 3; //g is primitive root of mod\n        int h = (int)mod_pow(g, (mod - 1) / n, mod); // h^n = 1\n        if (sign == -1) h = (int)mod_inv(h, mod); //h = h^-1 % mod\n\n        //bit reverse\n        int i = 0;\n        for (int j=1; j&lt;n-1; ++j) {\n            for (int k = n &gt;&gt; 1; k &gt;(i ^= k); k &gt;&gt;= 1);\n            if (j &lt; i) swap(a[i], a[j]);\n        }\n\n        for (int m=1; m&lt;n; m*=2) {\n            const int m2 = 2 * m;\n            const long long base = mod_pow(h, n / m2, mod);\n            long long w = 1;\n            for(int x=0; x&lt;m; x++) {\n                for (int s = x; s &lt; n; s += m2) {\n                    long long u = a[s];\n                    long long d = a[s + m] * w % mod;\n                    a[s] = u + d;\n                    if (a[s] &gt;= mod) a[s] -= mod;\n                    a[s + m] = u - d;\n                    if (a[s + m] &lt; 0) a[s + m] += mod;\n                }\n                w = w * base % mod;\n            }\n        }\n\n        for (auto&amp; x : a) if (x &lt; 0) x += mod;\n    }\n    void ntt(vector&lt;long long&gt;&amp; input) {\n        _ntt(input, 1);\n    }\n    void intt(vector&lt;long long&gt;&amp; input) {\n        _ntt(input, -1);\n        const int n_inv = mod_inv(input.size(), mod);\n        for (auto&amp; x : input) x = x * n_inv % mod;\n    }\n\n    // \u7573\u307f\u8fbc\u307f\u6f14\u7b97\u3092\u884c\u3046\n    vector&lt;long long&gt; convolution(const vector&lt;long long&gt;&amp; a, const vector&lt;long long&gt;&amp; b){\n        int ntt_size = 1;\n        while (ntt_size &lt; (int)(a.size()+b.size())) ntt_size *= 2;\n\n        vector&lt;long long&gt; _a = a, _b = b;\n        _a.resize(ntt_size); _b.resize(ntt_size);\n\n        ntt(_a);\n        ntt(_b);\n\n        for(int i=0; i&lt;ntt_size; i++){\n            (_a[i] *= _b[i]) %= mod;\n        }\n\n        intt(_a);\n        return _a;\n    }\n};\n\ntypedef NTT&lt;167772161,3&gt; NTT_1;\ntypedef NTT&lt;469762049,3&gt; NTT_2;\ntypedef NTT&lt;1224736769,3&gt; NTT_3;\n\n// garner\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u76f4\u66f8\u304d\u3057\u305fversion\uff0c\u901f\u3044\nvector&lt;long long&gt; int32mod_convolution(vector&lt;long long&gt; a, vector&lt;long long&gt; b,int mod){\n    for (auto&amp; x : a) x %= mod;\n    for (auto&amp; x : b) x %= mod;\n\n    NTT_1 ntt1; NTT_2 ntt2; NTT_3 ntt3;\n    assert(ntt1.get_mod() &lt; ntt2.get_mod() &amp;&amp; ntt2.get_mod() &lt; ntt3.get_mod());\n    auto x = ntt1.convolution(a, b);\n    auto y = ntt2.convolution(a, b);\n    auto z = ntt3.convolution(a, b);\n\n    // garner\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u6975\u529b\u9ad8\u901f\u5316\u3057\u305f\n    const long long m1 = ntt1.get_mod(), m2 = ntt2.get_mod(), m3 = ntt3.get_mod();\n    const long long m1_inv_m2 = mod_inv(m1, m2);\n    const long long m12_inv_m3 = mod_inv(m1 * m2, m3);\n    const long long m12_mod = m1 * m2 % mod;\n    vector&lt;long long&gt; ret(x.size());\n    for(int i=0; i&lt;(int)x.size(); i++){\n        long long v1 = (y[i] - x[i]) *  m1_inv_m2 % m2;\n        if (v1 &lt; 0) v1 += m2;\n        long long v2 = (z[i] - (x[i] + m1 * v1) % m3) * m12_inv_m3 % m3;\n        if (v2 &lt; 0) v2 += m3;\n        long long constants3 = (x[i] + m1 * v1 + m12_mod * v2) % mod;\n        if (constants3 &lt; 0) constants3 += mod;\n        ret[i] = constants3;\n    }\n\n    return ret;\n}\n\n//2^23\u3088\u308a\u5927\u304d\u304f\uff0cprimitive root\u306b3\u3092\u6301\u3064\u3082\u306e\n// const int mods[] = { 1224736769, 469762049, 167772161, 595591169, 645922817, 897581057, 998244353 };\n</code></pre>"},{"location":"math/floor_sum/","title":"Floor sum","text":"<p>calculate</p> \\[\\sum_{i = 0}^{n - 1} \\left\\lfloor \\frac{a \\times i + b}{m} \\right\\rfloor.\\] <p>return \\(\\bmod 2^{\\mathrm{64}}\\) if overflow</p> <p>constraints</p> <ul> <li>\\(0 \\leq n \\lt 2^{32}\\)</li> <li>\\(1 \\leq m \\lt 2^{32}\\)</li> </ul> <p>complexity</p> <ul> <li>\\(O(\\log m)\\)</li> </ul>"},{"location":"math/floor_sum/#c","title":"C++","text":"<pre><code>long long floor_sum(long long n, long long m, long long a, long long b) {\n    long long ans = 0;\n    if (a &gt;= m) {\n        ans += (n - 1) * n * (a / m) / 2;\n        a %= m;\n    }\n    if (b &gt;= m) {\n        ans += n * (b / m);\n        b %= m;\n    }\n\n    long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n    if (y_max == 0) return ans;\n    ans += (n - (x_max + a - 1) / a) * y_max;\n    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n    return ans;\n}\n</code></pre>"},{"location":"math/floor_sum/#example","title":"Example","text":"<ul> <li>ARC111 E - Simple Math 3 (C++)</li> </ul>"},{"location":"math/log_mod/","title":"Log mod","text":""},{"location":"math/log_mod/#c","title":"c++","text":"<pre><code>long long mul_modp(long long a, long long b){\n    // a*b mod p\n    return ((a % MOD) * (b % MOD)) % MOD;\n}\n\nlong long pow_modp(long long a, long long n){\n    // a^n mod p\n    long long res = 1;\n    while (n &gt; 0) {\n        if (n &amp; 1) res = mul_modp(res, a);\n        a = mul_modp(a, a);\n        n &gt;&gt;= 1;\n    }\n    return res;\n}\n\nlong long modinv(long long a){\n    // a^{-1} = 1/a mod p (\u62e1\u5f35Euclid\u306e\u4e92\u9664\u6cd5)\n    long long b = MOD, u = 1, v = 0;\n    while (b) {\n        long long t = a / b;\n        a -= t * b; swap(a, b);\n        u -= t * v; swap(u, v);\n    }\n    u %= MOD;\n    if (u &lt; 0) u += MOD;\n    return u;\n}\n\nlong long log_modp(long long a, long long b) {\n    // a^x \u2261 b (mod. m) \u3068\u306a\u308b\u6700\u5c0f\u306e\u6b63\u306e\u6574\u6570 x \u3092\u6c42\u3081\u308b\n    a %= MOD, b %= MOD;\n\n    // calc sqrt{M}\n    long long lo = -1, hi = MOD;\n    while (hi - lo &gt; 1) {\n        long long mid = (lo + hi) / 2;\n        if (mid * mid &gt;= MOD) hi = mid;\n        else lo = mid;\n    }\n    long long sqrtM = hi;\n\n    // {a^0, a^1, a^2, ..., a^sqrt(m)} \n    map&lt;long long, long long&gt; apow;\n    long long amari = 1;\n    for (long long r = 0; r &lt; sqrtM; ++r) {\n        if (!apow.count(amari)) apow[amari] = r;\n        (amari *= a) %= MOD;\n    }\n\n    // check each A^p\n    long long A = pow_modp(modinv(a), sqrtM);\n    amari = b;\n    for (long long q = 0; q &lt; sqrtM; ++q) {\n        if (apow.count(amari)) {\n            long long res = q * sqrtM + apow[amari];\n            if (res &gt; 0) return res;\n        }\n        (amari *= A) %= MOD;\n    }\n\n    // no solutions\n    return -1;\n}\n</code></pre>"},{"location":"math/modint/","title":"Modint","text":""},{"location":"math/modint/#c","title":"c++","text":"<pre><code>template&lt;long long mod=1000000007&gt;\nstruct modint {\n    long long x;\n    modint(long long x=0):x((x%mod+mod)%mod){}\n    long long val(){\n        return x;\n    }\n    modint&lt;mod&gt; operator-() const { return modint(-x);}\n    modint&lt;mod&gt;&amp; operator+=(const modint a) {\n        if ((x += a.x) &gt;= mod) x -= mod;\n        return *this;\n    }\n    modint&lt;mod&gt;&amp; operator-=(const modint a) {\n        if ((x += mod-a.x) &gt;= mod) x -= mod;\n        return *this;\n    }\n    modint&lt;mod&gt;&amp; operator*=(const modint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    modint&lt;mod&gt; operator+(const modint a) const {\n        modint&lt;mod&gt; res(*this);\n        return res+=a;\n    }\n    modint&lt;mod&gt; operator-(const modint a) const {\n        modint&lt;mod&gt; res(*this);\n        return res-=a;\n    }\n    modint&lt;mod&gt; operator*(const modint a) const {\n        modint&lt;mod&gt; res(*this);\n        return res*=a;\n    }\n    modint&lt;mod&gt; pow(long long t) const {\n        if (!t) return 1;\n        modint&lt;mod&gt; a = pow(t&gt;&gt;1);\n        a *= a;\n        if (t&amp;1) a *= *this;\n        return a;\n    }\n\n    // must be gcd(x,mod)==1\n    modint&lt;mod&gt; inv() const {\n        // a^{-1} = 1/a mod p (\u62e1\u5f35Euclid\u306e\u4e92\u9664\u6cd5)\n        long long b = mod, u = 1, v = 0, z = x;\n        while(b){\n            long long t = z / b;\n            z -= t * b; swap(z, b);\n            u -= t * v; swap(u, v);\n        }\n        u %= mod;\n        if (u &lt; 0) u += mod;\n        return modint&lt;mod&gt;(u);\n    }\n\n    //modint inv() const {\n    //    return pow(mod-2);\n    //}\n\n    modint&lt;mod&gt;&amp; operator/=(const modint a) {\n        return (*this) *= a.inv();\n    }\n    modint&lt;mod&gt; operator/(const modint a) const {\n        modint&lt;mod&gt; res(*this);\n        return res/=a;\n    }\n};\nusing mint = modint&lt;998244353&gt;;\n</code></pre>"},{"location":"math/modint/#rust","title":"Rust","text":"<pre><code>pub mod modint {\n    use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};\n    type Int = u128;\n\n    #[derive(Clone, Copy)]\n    pub struct ModInt(pub Int);\n\n    impl ModInt {\n        const MOD: Int = 998244353;\n\n        pub fn new(x: Int) -&gt; Self {\n            Self(x % Self::MOD)\n        }\n\n        pub fn add(&amp;self, other: Self) -&gt; Self {\n            let mut val = self.0 + other.0;\n            if val &gt;= Self::MOD {\n                val -= Self::MOD;\n            }\n            Self(val)\n        }\n\n        pub fn sub(&amp;self, other: Self) -&gt; Self {\n            let val = if self.0 &gt;= other.0 {\n                self.0 - other.0\n            } else {\n                Self::MOD - other.0 + self.0\n            };\n            Self(val)\n        }\n\n        pub fn mul(&amp;self, other: Self) -&gt; Self {\n            Self((self.0 * other.0) % Self::MOD)\n        }\n\n        pub fn div(&amp;self, other: Self) -&gt; Self {\n            self.mul(other.inv())\n        }\n\n        pub fn pow(&amp;self, mut n: Int) -&gt; Self {\n            let mut val = 1;\n            let mut pow = self.0;\n            while n &gt; 0 {\n                if (n &amp; 1) == 1 {\n                    val = (val * pow) % Self::MOD;\n                }\n                pow = (pow * pow) % Self::MOD;\n                n &gt;&gt;= 1;\n            }\n            Self(val)\n        }\n\n        pub fn inv(&amp;self) -&gt; Self {\n            self.pow(Self::MOD - 2)\n        }\n    }\n\n    impl Add for ModInt {\n        type Output = ModInt;\n        fn add(self, rhs: Self) -&gt; Self::Output {\n            ModInt::add(&amp;self, rhs)\n        }\n    }\n\n    impl Sub for ModInt {\n        type Output = ModInt;\n        fn sub(self, rhs: Self) -&gt; Self::Output {\n            ModInt::sub(&amp;self, rhs)\n        }\n    }\n\n    impl Mul for ModInt {\n        type Output = ModInt;\n        fn mul(self, rhs: Self) -&gt; Self::Output {\n            ModInt::mul(&amp;self, rhs)\n        }\n    }\n\n    impl Div for ModInt {\n        type Output = ModInt;\n        fn div(self, rhs: Self) -&gt; Self::Output {\n            ModInt::div(&amp;self, rhs)\n        }\n    }\n\n    impl Add&lt;Int&gt; for ModInt {\n        type Output = ModInt;\n        fn add(self, rhs: Int) -&gt; Self::Output {\n            ModInt::add(&amp;self, Self::new(rhs))\n        }\n    }\n\n    impl Sub&lt;Int&gt; for ModInt {\n        type Output = ModInt;\n        fn sub(self, rhs: Int) -&gt; Self::Output {\n            ModInt::sub(&amp;self, Self::new(rhs))\n        }\n    }\n\n    impl Mul&lt;Int&gt; for ModInt {\n        type Output = ModInt;\n        fn mul(self, rhs: Int) -&gt; Self::Output {\n            ModInt::mul(&amp;self, Self::new(rhs))\n        }\n    }\n\n    impl Div&lt;Int&gt; for ModInt {\n        type Output = ModInt;\n        fn div(self, rhs: Int) -&gt; Self::Output {\n            ModInt::div(&amp;self, Self::new(rhs))\n        }\n    }\n\n    impl AddAssign&lt;ModInt&gt; for ModInt {\n        fn add_assign(&amp;mut self, rhs: ModInt) {\n            *self = self.add(rhs);\n        }\n    }\n\n    impl SubAssign&lt;ModInt&gt; for ModInt {\n        fn sub_assign(&amp;mut self, rhs: ModInt) {\n            *self = self.sub(rhs);\n        }\n    }\n\n    impl MulAssign&lt;ModInt&gt; for ModInt {\n        fn mul_assign(&amp;mut self, rhs: ModInt) {\n            *self = self.mul(rhs);\n        }\n    }\n\n    impl DivAssign&lt;ModInt&gt; for ModInt {\n        fn div_assign(&amp;mut self, rhs: ModInt) {\n            *self = self.div(rhs);\n        }\n    }\n\n    impl AddAssign&lt;Int&gt; for ModInt {\n        fn add_assign(&amp;mut self, rhs: Int) {\n            *self = self.add(rhs);\n        }\n    }\n\n    impl SubAssign&lt;Int&gt; for ModInt {\n        fn sub_assign(&amp;mut self, rhs: Int) {\n            *self = self.sub(rhs);\n        }\n    }\n\n    impl MulAssign&lt;Int&gt; for ModInt {\n        fn mul_assign(&amp;mut self, rhs: Int) {\n            *self = self.mul(rhs);\n        }\n    }\n\n    impl DivAssign&lt;Int&gt; for ModInt {\n        fn div_assign(&amp;mut self, rhs: Int) {\n            *self = self.div(rhs);\n        }\n    }\n}\n</code></pre>"},{"location":"math/next_combination/","title":"Next combination","text":""},{"location":"math/next_combination/#c","title":"c++","text":"<pre><code>template &lt;typename Iterator&gt;\ninline bool next_combination(const Iterator first, Iterator k, const Iterator last)\n{\n    /* Credits: Thomas Draper */\n    if ((first == last) || (first == k) || (last == k))\n        return false;\n    Iterator itr1 = first;\n    Iterator itr2 = last;\n    ++itr1;\n    if (last == itr1)\n        return false;\n    itr1 = last;\n    --itr1;\n    itr1 = k;\n    --itr2;\n    while (first != itr1){\n        if (*--itr1 &lt; *itr2){\n            Iterator j = k;\n            while (!(*itr1 &lt; *j)) ++j;\n            iter_swap(itr1,j);\n            ++itr1;\n            ++j;\n            itr2 = k;\n            rotate(itr1,j,last);\n            while (last != j){\n                ++j;\n                ++itr2;\n            }\n            rotate(k,itr2,last);\n            return true;\n        }\n    }\n    rotate(first,k,last);\n    return false;\n}\n</code></pre>"},{"location":"math/prime/","title":"Prime","text":""},{"location":"math/prime/#c","title":"C++","text":"<pre><code>bool is_prime(long long num) {\n    if (num &lt; 2) return false;\n    else if (num == 2) return true;\n    else if (num % 2 == 0) return false; // \u5076\u6570\u306f\u3042\u3089\u304b\u3058\u3081\u9664\u304f\n\n    for (long long i = 3; i*i &lt;= num; i += 2) {\n        if (num % i == 0) {\n            // \u7d20\u6570\u3067\u306f\u306a\u3044\n            return false;\n        }\n    }\n\n    // \u7d20\u6570\u3067\u3042\u308b\n    return true;\n}\n</code></pre>"},{"location":"matrix/matrix_power/","title":"Matrix power","text":"<p>calculate</p> \\[A^k\\boldsymbol{x},\\ A \\in \\mathbb{R}^{N\\times N},\\ \\boldsymbol{x} \\in \\mathbb{R}^{N},\\ k \\in \\mathbb{N}\\] <p>constraints</p> <ul> <li>\\(0 \\leq k \\leq 10^{18}\\)</li> </ul> <p>complexity</p> <ul> <li>\\(\\mathrm{O}(N^3\\log k)\\)</li> </ul>"},{"location":"matrix/matrix_power/#c","title":"C++","text":"<pre><code>template&lt;class T&gt;\nstd::vector&lt;T&gt; matmul(std::vector&lt;std::vector&lt;T&gt;&gt; &amp;A, std::vector&lt;T&gt; &amp;v) {\n    int n = A.size(), m = v.size();\n    std::vector&lt;T&gt; ret(n, 0);\n\n    for(int i = 0; i &lt; n; i++)\n        for(int j = 0; j &lt; m; j++)\n            ret[i] += A[i][j] + v[j];\n\n    return ret;\n}\n\ntemplate&lt;class T&gt;\nstd::vector&lt;std::vector&lt;T&gt;&gt; matmul(std::vector&lt;std::vector&lt;T&gt;&gt; &amp;A, std::vector&lt;std::vector&lt;T&gt;&gt; &amp;B) {\n    int n = A.size(), m = B.size(), l = B[0].size();\n    std::vector&lt;std::vector&lt;T&gt;&gt; ret(n, std::vector&lt;T&gt;(l,0));\n\n    for(int i = 0; i &lt; n; i++)\n        for(int k = 0; k &lt; m; k++)\n            for(int j = 0; j &lt; l; j++)\n                ret[i][j] += A[i][k] * B[k][j];\n\n    return ret;\n}\n\ntemplate&lt;class T&gt;\nstd::vector&lt;std::vector&lt;T&gt;&gt; matpow(std::vector&lt;std::vector&lt;T&gt;&gt; &amp;mat, long long k) {\n    int n = mat.size();\n    bool first = true;\n    // k == 0 \u306e\u3068\u304d\u306f\u660e\u793a\u7684\u306b\u5358\u4f4d\u884c\u5217\u3067\u521d\u671f\u5316\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\n    std::vector&lt;std::vector&lt;T&gt;&gt; ret;\n\n    while(k){\n        if(k &amp; 1) {\n            if(first) {\n                ret = mat;\n                first = false;\n            } else {\n                ret = matmul(mat, ret);\n            }\n        }\n        mat = matmul(mat, mat);\n        k &gt;&gt;= 1;\n    }\n\n    return ret;\n}\n</code></pre>"},{"location":"matrix/matrix_power/#example","title":"Example","text":"<ul> <li>ABC009 D - \u6f38\u5316\u5f0f (C++)</li> <li>ABC236 G - Good Vertices (C++)</li> <li>Educational DP Contest R - Walk (C++)</li> </ul>"},{"location":"matrix/xor_base/","title":"Xor base","text":""},{"location":"matrix/xor_base/#c","title":"C++","text":"<pre><code>std::vector&lt;long long&gt; calc_base(std::vector&lt;long long&gt; &amp;v) {\n    std::vector&lt;long long&gt; base;\n\n    for (long long x : v) {\n        for (long long b : base)\n            x = std::min(x, b ^ x);\n        if (x &gt; 0)\n            base.push_back(x);\n    }\n\n    return base;\n}\n</code></pre>"},{"location":"misc/elapsed_time/","title":"Elapsed time","text":""},{"location":"misc/elapsed_time/#c","title":"C++","text":"<pre><code>inline double get_time_ms(void){\n    return static_cast&lt;double&gt;(\n        std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(std::chrono::steady_clock::now().time_since_epoch()).count()\n        )/1000000;\n}\n</code></pre>"},{"location":"misc/floor_group/","title":"Floor group","text":""},{"location":"misc/floor_group/#c","title":"C++","text":"<p>\\(\\mathcal{O}(\\log N)\\) <pre><code>int l = 1;\nwhile(l&lt;=N){\n    int r = N/(N/l)+1; // [l,r)\u306f\u5546\u304c\u540c\u3058\n    cout &lt;&lt; \"[\" &lt;&lt; l &lt;&lt; \",\" &lt;&lt; r &lt;&lt; \")\" &lt;&lt; endl;\n    l = r;\n}\n</code></pre></p>"},{"location":"misc/remove_duplication/","title":"Remove duplication","text":""},{"location":"misc/remove_duplication/#c","title":"C++","text":"<pre><code>template&lt;class T&gt;\nstd::vector&lt;T&gt; remove_duplication(std::vector&lt;T&gt; v){\n    std::sort(v.begin(), v.end());\n    v.erase(std::unique(v.begin(), v.end()), v.end());\n    return v;\n}\n</code></pre>"},{"location":"random/mersenne_twister/","title":"Mersenne twister","text":""},{"location":"random/mersenne_twister/#c","title":"C++","text":"<pre><code>struct RNG {\n    std::mt19937_64 mt;\n\n    RNG(int seed = -1) {\n        if (seed == -1) {\n            std::random_device rnd; // \u975e\u6c7a\u5b9a\u7684\u306a\u4e71\u6570\u751f\u6210\u5668\n            mt = std::mt19937_64(rnd());\n        } else {\n            mt = std::mt19937_64(seed);\n        }\n    }\n\n    unsigned long long gen() {\n        return mt();\n    }\n\n    template &lt;class T&gt;\n    T gen(T l, T r) {\n        // generate random number in [l, r]\n        return l + gen() % (r - l + 1);\n    }\n};\n</code></pre>"},{"location":"random/random_generator/","title":"Random generator","text":""},{"location":"random/random_generator/#rust","title":"Rust","text":"<pre><code>pub mod rand_generator {\n    use num_traits::PrimInt;\n    use rand::{seq::SliceRandom, Rng};\n    use rand_chacha::{rand_core::SeedableRng, ChaCha20Rng};\n    use rand_distr::{Distribution, Normal};\n\n    pub struct RandomGenerator {\n        rng: ChaCha20Rng,\n    }\n\n    impl RandomGenerator {\n        pub fn new(seed: u64) -&gt; Self {\n            Self { rng: get_rng(seed) }\n        }\n\n        pub fn gen_normal(&amp;mut self, mean: f64, std: f64) -&gt; f64 {\n            let normal_dist = Normal::&lt;f64&gt;::new(mean, std).unwrap();\n            normal_dist.sample(&amp;mut self.rng)\n        }\n\n        pub fn gen_range&lt;T: PrimInt&gt;(&amp;mut self, low: i64, high: i64, equal: bool) -&gt; T {\n            if equal {\n                T::from(self.rng.gen_range(low..=high)).unwrap()\n            } else {\n                T::from(self.rng.gen_range(low..high)).unwrap()\n            }\n        }\n\n        pub fn gen_bool(&amp;mut self, prob: f64) -&gt; bool {\n            self.rng.gen_bool(prob.clamp(0.0, 1.0))\n        }\n\n        pub fn gen_permutation(&amp;mut self, n: usize) -&gt; Vec&lt;usize&gt; {\n            let mut permutation: Vec&lt;usize&gt; = (1..=n).collect();\n            permutation.shuffle(&amp;mut self.rng);\n            permutation\n        }\n\n        pub fn shuffle&lt;T&gt;(&amp;mut self, v: &amp;mut Vec&lt;T&gt;) {\n            v.shuffle(&amp;mut self.rng);\n        }\n    }\n\n    fn get_rng(seed: u64) -&gt; ChaCha20Rng {\n        ChaCha20Rng::seed_from_u64(seed)\n    }\n}\n</code></pre>"},{"location":"random/xor_shift_128/","title":"Xor shift 128","text":""},{"location":"random/xor_shift_128/#c","title":"C++","text":"<pre><code>struct FastRNG {\n    unsigned long long x, y, z, w;\n\n    FastRNG(int seed = -1) {\n        std::mt19937_64 mt;\n        if (seed == -1) {\n            std::random_device rnd; // \u975e\u6c7a\u5b9a\u7684\u306a\u4e71\u6570\u751f\u6210\u5668\n            mt = std::mt19937_64(rnd());\n        } else {\n            mt = std::mt19937_64(seed);\n        }\n        set_parameter(mt);\n    }\n\n    unsigned long long gen() {\n        return xor128();\n    }\n\n    template &lt;class T&gt;\n    T gen(T l, T r) {\n        // generate random number in [l, r]\n        return l + gen() % (r - l + 1);\n    }\n\n  private:\n    void set_parameter(std::mt19937_64 mt) {\n        x = mt();\n        y = mt();\n        z = mt();\n        w = mt();\n    }\n\n    unsigned long long xor128() {\n        unsigned long long t = (x ^ (x &lt;&lt; 11));\n        x = y;\n        y = z;\n        z = w;\n        return (w = (w ^ (w &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8)));\n    }\n};\n</code></pre>"},{"location":"sort/argsort/","title":"Argsort","text":""},{"location":"sort/argsort/#c","title":"c++","text":"<pre><code>auto argsort = [&amp;](int i, int j){\n    // [-PI, PI)\u3067\u30bd\u30fc\u30c8\n    long double thetai = atan2l(y[i], x[i]);\n    long double thetaj = atan2l(y[j], x[j]);\n    return thetai &lt; thetaj;\n};\nvector&lt;int&gt; p(N); for(int i=0; i&lt;N; i++) p[i] = i;\nsort(p.begin(), p.end(), argsort);\n</code></pre>"},{"location":"sort/topological_sort/","title":"Topological sort","text":""},{"location":"sort/topological_sort/#c","title":"c++","text":"<pre><code>stack&lt;int&gt; stk;\nfor(int i=0; i&lt;N; i++) if(deg[i] == 0) stk.push(i);\n\nvector&lt;int&gt; sorted;\nwhile(stk.size()){\n    int i = stk.top(); stk.pop();\n    sorted.push_back(i);\n    for(int j : e[i]){\n        deg[j]--;\n        if(deg[j] == 0) stk.push(j);\n    }\n}\n</code></pre>"},{"location":"string/Knuth_Morris_Pratt/","title":"Knuth Morris Pratt","text":""},{"location":"string/Knuth_Morris_Pratt/#c","title":"C++","text":"<pre><code>template &lt;class T&gt;\nstd::vector&lt;int&gt; KMP(std::vector&lt;T&gt; &amp;v) {\n    int N = v.size(), j = -1;\n    std::vector&lt;int&gt; A(N + 1);\n    A[0] = -1;\n    for (int i = 0; i &lt; N; i++) {\n        while (j &gt;= 0 &amp;&amp; v[i] != v[j])\n            j = A[j];\n        if (i &lt; N - 1 and v[i + 1] == v[j])\n            A[i + 1] = A[++j];\n        else\n            A[i + 1] = ++j;\n    }\n    return A;\n}\n\nstd::vector&lt;int&gt; KMP(std::string &amp;s) {\n    int N = s.size();\n    std::vector&lt;char&gt; v(N);\n    for (int i = 0; i &lt; N; i++)\n        v[i] = s[i];\n    return KMP(v);\n}\n</code></pre>"},{"location":"string/Knuth_Morris_Pratt/#reference","title":"Reference","text":"<ul> <li>https://www.slideshare.net/hcpc_hokudai/ss-121539419</li> </ul>"},{"location":"string/Morris_Pratt/","title":"Morris Pratt","text":"<p>\u9577\u3055 \\(N\\) \u306e\u6587\u5b57\u5217 \\(S\\) \u306b\u5bfe\u3057\u3066\u3001\u6570\u5217 \\(A_i (i=1, \\ldots, N+1)\\) \u3092\u6c42\u3081\u308b</p> \\[A_i = S_{1, \\ldots, i-1}\\text{\u306e\u63a5\u982d\u8f9e\u3068\u63a5\u5c3e\u8f9e\u304c\u6700\u5927\u4f55\u6587\u5b57\u4e00\u81f4\u3057\u3066\u3044\u308b\u304b}\\] <p>complaxity</p> <ul> <li>\\(O(N)\\)</li> </ul>"},{"location":"string/Morris_Pratt/#c","title":"C++","text":"<pre><code>template &lt;class T&gt;\nstd::vector&lt;int&gt; MP(std::vector&lt;T&gt; &amp;v) {\n    int N = v.size(), j = -1;\n    std::vector&lt;int&gt; A(N + 1);\n    A[0] = -1;\n    for (int i = 0; i &lt; N; i++) {\n        while (j &gt;= 0 &amp;&amp; v[i] != v[j])\n            j = A[j];\n        A[i + 1] = ++j;\n    }\n    return A;\n}\n\nstd::vector&lt;int&gt; MP(std::string &amp;s) {\n    int N = s.size();\n    std::vector&lt;char&gt; v(N);\n    for (int i = 0; i &lt; N; i++)\n        v[i] = s[i];\n    return MP(v);\n}\n</code></pre>"},{"location":"string/Morris_Pratt/#reference","title":"Reference","text":"<ul> <li>https://www.slideshare.net/hcpc_hokudai/ss-121539419</li> </ul>"},{"location":"string/dynamic_rolling_hash/","title":"Dynamic rolling hash","text":""},{"location":"string/dynamic_rolling_hash/#c","title":"C++","text":"<p><pre><code>struct RNG {\n    std::mt19937_64 mt;\n\n    RNG(int seed = -1) {\n        if (seed == -1) {\n            std::random_device rnd; // \u975e\u6c7a\u5b9a\u7684\u306a\u4e71\u6570\u751f\u6210\u5668\n            mt = std::mt19937_64(rnd());\n        } else {\n            mt = std::mt19937_64(seed);\n        }\n    }\n\n    unsigned long long gen() {\n        return mt();\n    }\n\n    template &lt;class T&gt;\n    T gen(T l, T r) {\n        // generate random number in [l, r]\n        return l + gen() % (r - l + 1);\n    }\n};\n\ntemplate &lt;class T&gt;\nstruct DynamicRollingHash {\n    const long long MASK30 = (1LL &lt;&lt; 30) - 1;\n    const long long MASK31 = (1LL &lt;&lt; 31) - 1;\n    const long long MOD = (1LL &lt;&lt; 61) - 1;\n    const long long MASK61 = MOD;\n\n    struct Data {\n        long long hs;\n        int length;\n        Data(long long hs, int length) : hs(hs), length(length) {}\n    };\n\n    int N, size;\n    std::vector&lt;long long&gt; b;\n    std::vector&lt;Data&gt; data;\n\n    DynamicRollingHash(std::vector&lt;T&gt; &amp;a, long long base_ = -1) {\n        build(a, base_);\n    }\n\n    DynamicRollingHash(std::string &amp;s, long long base_ = -1) {\n        int n = s.size();\n        std::vector&lt;T&gt; a(n);\n        for (int i = 0; i &lt; n; i++)\n            a[i] = s[i];\n        build(a, base_);\n    }\n\n    long long get(int l, int r) {\n        l += size;\n        r += size;\n        Data vl(0, 0), vr(0, 0);\n        int length = 1;\n        while (l &lt; r) {\n            if (l &amp; 1)\n                vl = op(vl, data[l++]);\n            if (r &amp; 1)\n                vr = op(data[--r], vr);\n            l &gt;&gt;= 1;\n            r &gt;&gt;= 1;\n            length &lt;&lt;= 1;\n        }\n        return op(vl, vr).hs;\n    }\n\n    void set(int p, T x) {\n        p += size;\n        data[p] = Data(1LL * x, 1);\n        while (p &gt; 1) {\n            p &gt;&gt;= 1;\n            update(p);\n        }\n    }\n\n  private:\n    void build(std::vector&lt;T&gt; &amp;a, long long base_ = -1) {\n        long long base = -1;\n        if (base_ == -1) {\n            RNG rng(base_);\n            base = rng.gen(2LL, 1LL &lt;&lt; 60);\n        } else {\n            base = base_;\n        }\n\n        N = a.size();\n        size = std::bit_ceil(uint32_t(N));\n        data.resize(size &lt;&lt; 1, Data(0, 0));\n        b.resize(size + 1);\n        b[0] = 1;\n        for (int i = 0; i &lt; N; i++)\n            data[size + i] = Data(a[i], 1);\n\n        for (int i = 0; i &lt; size; i++)\n            b[i + 1] = Mul(b[i], base);\n\n        for (int i = size - 1; i &gt; 0; i--)\n            update(i);\n    }\n\n    void update(int k) {\n        data[k] = op(data[k &lt;&lt; 1], data[(k &lt;&lt; 1) + 1]);\n    }\n\n    Data op(Data vl, Data vr) {\n        long long hs = Mul(vl.hs, b[vr.length]) + vr.hs;\n        int length = vl.length + vr.length;\n        if (hs &gt;= MOD)\n            hs -= MOD;\n        return Data(hs, length);\n    }\n\n    // mod 2^61-1\u3092\u8a08\u7b97\u3059\u308b\u95a2\u6570\n    long long CalcMod(long long x) {\n        long long xu = x &gt;&gt; 61;\n        long long xd = x &amp; MASK61;\n        long long ret = xu + xd;\n        if (ret &gt;= MOD)\n            ret -= MOD;\n        return ret;\n    }\n\n    // a*b mod 2^61-1\u3092\u8fd4\u3059\u95a2\u6570(\u6700\u5f8c\u306bMod\u3092\u53d6\u308b)\n    long long Mul(long long a, long long b) {\n        long long au = a &gt;&gt; 31;\n        long long ad = a &amp; MASK31;\n        long long bu = b &gt;&gt; 31;\n        long long bd = b &amp; MASK31;\n        long long mid = ad * bu + au * bd;\n        long long midu = mid &gt;&gt; 30;\n        long long midd = mid &amp; MASK30;\n        return CalcMod(au * bu * 2 + midu + (midd &lt;&lt; 31) + ad * bd);\n    }\n};\n</code></pre> <pre><code>struct RNG {\n    std::mt19937_64 mt;\n\n    RNG(int seed = -1) {\n        if (seed == -1) {\n            std::random_device rnd; // \u975e\u6c7a\u5b9a\u7684\u306a\u4e71\u6570\u751f\u6210\u5668\n            mt = std::mt19937_64(rnd());\n        } else {\n            mt = std::mt19937_64(seed);\n        }\n    }\n\n    unsigned long long gen() {\n        return mt();\n    }\n\n    template &lt;class T&gt;\n    T gen(T l, T r) {\n        // generate random number in [l, r]\n        return l + gen() % (r - l + 1);\n    }\n};\n\ntemplate &lt;class T&gt;\nstruct DynamicRollingHash {\n    const long long MASK30 = (1LL &lt;&lt; 30) - 1;\n    const long long MASK31 = (1LL &lt;&lt; 31) - 1;\n    const long long MOD = (1LL &lt;&lt; 61) - 1;\n    const long long MASK61 = MOD;\n\n    // size := #leaves of segment tree\n    // depth := depth of segment tree\n    int N, size, depth;\n    std::vector&lt;long long&gt; hs, b, lazy;\n    std::vector&lt;T&gt; v;\n\n    DynamicRollingHash(std::vector&lt;T&gt; &amp;a, long long base_ = -1) {\n        build(a, base_);\n    }\n\n    DynamicRollingHash(std::string &amp;s, long long base_ = -1) {\n        int n = s.size();\n        std::vector&lt;T&gt; a(n);\n        for (int i = 0; i &lt; n; i++)\n            a[i] = s[i];\n        build(a, base_);\n    }\n\n    long long get(int l, int r) {\n        long long ret = get(r - 1) + MOD - Mul(get(l - 1), b[r - l]);\n        if (ret &gt;= MOD)\n            ret -= MOD;\n        return ret;\n    }\n\n    void set(int p, T x) {\n        T d = x - v[p];\n        v[p] = x;\n        apply(p, N, d);\n    }\n\n  private:\n    void build(std::vector&lt;T&gt; &amp;a, long long base_ = -1) {\n        long long base = -1;\n        if (base_ == -1) {\n            RNG rng(base_);\n            base = rng.gen(2LL, 1LL &lt;&lt; 60);\n        } else {\n            base = base_;\n        }\n\n        N = a.size();\n        hs.resize(N + 1);\n        b.resize(N + 1);\n        b[0] = 1;\n        hs[0] = 0;\n        for (int i = 0; i &lt; N; i++) {\n            b[i + 1] = Mul(b[i], base);\n            hs[i + 1] = Mul(hs[i], base) + a[i];\n            if (hs[i + 1] &gt;= MOD)\n                hs[i + 1] -= MOD;\n        }\n\n        build_lazy(a);\n    }\n\n    void build_lazy(std::vector&lt;T&gt; &amp;a) {\n        N = a.size();\n        size = std::bit_ceil(uint32_t(N));\n        depth = std::bit_width(uint32_t(size)) - 1;\n        v = a;\n        lazy.resize(size &lt;&lt; 1, 0);\n    }\n\n    long long get(int x) {\n        if (x == -1)\n            return 0;\n        x += size;\n        int length = size;\n        for (int i = depth; i &gt;= 0; i--) {\n            push(x &gt;&gt; i, length);\n            length &gt;&gt;= 1;\n        }\n        return hs[x - size + 1];\n    }\n\n    void apply(int l, int r, long long x) {\n        l += size;\n        r += size;\n        int l0 = l, i = 0;\n        while (l &lt; r) {\n            if (l &amp; 1) {\n                assign_add(lazy[l], Mul(x, b[(l &lt;&lt; i) - l0]));\n                l++;\n            }\n            if (r &amp; 1) {\n                r--;\n                assign_add(lazy[r], Mul(x, b[(r &lt;&lt; i) - l0]));\n            }\n            l &gt;&gt;= 1;\n            r &gt;&gt;= 1;\n            i++;\n        }\n    }\n\n    void push(int k, int segment_length) {\n        // lazy[k] \u3092\u5b50\u306b\u4f1d\u64ad\u3055\u305b\u308b\n        if (k &lt; size) {\n            int l = k &lt;&lt; 1, r = l + 1;\n            assign_add(lazy[l], lazy[k]);\n            assign_add(lazy[r], Mul(lazy[k], b[segment_length &gt;&gt; 1]));\n        } else {\n            assign_add(hs[k - size + 1], lazy[k]);\n        }\n        lazy[k] = 0;\n    }\n\n    // (a += b) %= MOD \u3092\u3059\u308b\u95a2\u6570\n    void assign_add(long long &amp;a, long long b) {\n        a += b;\n        if (a &gt;= MOD)\n            a -= MOD;\n    }\n\n    // mod 2^61-1\u3092\u8a08\u7b97\u3059\u308b\u95a2\u6570\n    long long CalcMod(long long x) {\n        long long xu = x &gt;&gt; 61;\n        long long xd = x &amp; MASK61;\n        long long ret = xu + xd;\n        if (ret &gt;= MOD)\n            ret -= MOD;\n        return ret;\n    }\n\n    // a*b mod 2^61-1\u3092\u8fd4\u3059\u95a2\u6570(\u6700\u5f8c\u306bMod\u3092\u53d6\u308b)\n    long long Mul(long long a, long long b) {\n        long long au = a &gt;&gt; 31;\n        long long ad = a &amp; MASK31;\n        long long bu = b &gt;&gt; 31;\n        long long bd = b &amp; MASK31;\n        long long mid = ad * bu + au * bd;\n        long long midu = mid &gt;&gt; 30;\n        long long midd = mid &amp; MASK30;\n        return CalcMod(au * bu * 2 + midu + (midd &lt;&lt; 31) + ad * bd);\n    }\n};\n</code></pre></p>"},{"location":"string/dynamic_rolling_hash/#example","title":"Example","text":"<ul> <li>ABC331 F - Palindrome Query (C++)</li> </ul>"},{"location":"string/manachar/","title":"Manachar","text":"<p>\u9577\u3055 \\(N\\) \u306e\u6587\u5b57\u5217 \\(S\\) \u306b\u5bfe\u3057\u3066\u3001\\(S_i\\) \u3092\u4e2d\u5fc3\u3068\u3057\u305f\u56de\u6587\u306e\u9577\u3055\u306e\u534a\u5f84\u3092\u6c42\u3081\u308b\u3002 \u9577\u3055\u304c\u5076\u6570\u306e\u56de\u6587\u306f\u3001\u5404\u6587\u5b57\u306e\u9593\u306b\u7279\u5225\u306a\u6587\u5b57\u3092\u633f\u5165\u3059\u308b\u3053\u3068\u3067\u6c42\u3081\u3089\u308c\u308b</p> <p>complexity</p> <ul> <li>\\(O(\\log N)\\)</li> </ul>"},{"location":"string/manachar/#c","title":"C++","text":"<pre><code>template &lt;class T&gt;\nstd::vector&lt;int&gt; manachar(std::vector&lt;T&gt; &amp;v) {\n    // c := \u73fe\u6642\u70b9\u3067\u53f3\u7aef\u304c\u6700\u5927\u306b\u306a\u308b\u3088\u3046\u306a\u56de\u6587\u306e\u4e2d\u5fc3\n    int c = 0, n = int(v.size());\n    std::vector&lt;int&gt; r(n, 1);\n\n    for (int i = 0; i &lt; n; i++) {\n        int j = c - (i - c); // c \u3092\u4e2d\u5fc3\u3068\u3057\u3066, i \u3068\u5bfe\u79f0\u3068\u306a\u308b\u4f4d\u7f6e\n        if (i + r[j] &lt; c + r[c]) {\n            r[i] = r[j];\n        } else {\n            int len = c + r[c] - i; // c \u306e\u53f3\u7aef\u3068 i \u306e\u8ddd\u96e2 = \u73fe\u6642\u70b9\u3067\u78ba\u5b9a\u3057\u3066\u308b\u56de\u6587\u306e\u9577\u3055\n            while (i - len &gt;= 0 and i + len &lt; n and v[i - len] == v[i + len])\n                len++;\n            r[i] = len;\n            c = i;\n        }\n    }\n\n    return r;\n}\n\nstd::vector&lt;int&gt; manachar(std::string &amp;s) {\n    int n = s.size();\n    std::vector&lt;char&gt; v(n);\n    for (int i = 0; i &lt; n; i++)\n        v[i] = s[i];\n    return manachar(v);\n}\n</code></pre>"},{"location":"string/manachar/#reference","title":"Reference","text":"<ul> <li>https://www.slideshare.net/hcpc_hokudai/ss-121539419</li> </ul>"},{"location":"string/rolling_hash/","title":"Rolling hash","text":""},{"location":"string/rolling_hash/#c","title":"C++","text":"<pre><code>struct RNG {\n    std::mt19937_64 mt;\n\n    RNG(int seed = -1) {\n        if (seed == -1) {\n            std::random_device rnd; // \u975e\u6c7a\u5b9a\u7684\u306a\u4e71\u6570\u751f\u6210\u5668\n            mt = std::mt19937_64(rnd());\n        } else {\n            mt = std::mt19937_64(seed);\n        }\n    }\n\n    unsigned long long gen() {\n        return mt();\n    }\n\n    template &lt;class T&gt;\n    T gen(T l, T r) {\n        // generate random number in [l, r]\n        return l + gen() % (r - l + 1);\n    }\n};\n\nstruct RollingHash {\n    const long long MASK30 = (1LL &lt;&lt; 30) - 1;\n    const long long MASK31 = (1LL &lt;&lt; 31) - 1;\n    const long long MOD = (1LL &lt;&lt; 61) - 1;\n    const long long MASK61 = MOD;\n\n    int N;\n    std::vector&lt;long long&gt; hs, b;\n    long long base;\n\n    template &lt;typename T&gt;\n    RollingHash(std::vector&lt;T&gt; &amp;a, long long base_ = -1) {\n        _build(a, base_);\n    }\n\n    RollingHash(std::string &amp;s, long long base_ = -1) {\n        int n = s.size();\n        std::vector&lt;char&gt; a(n);\n        for (int i = 0; i &lt; n; i++)\n            a[i] = s[i];\n        _build(a, base_);\n    }\n\n    long long get(int l, int r) {\n        long long ret = hs[r] + MOD - Mul(hs[l], b[r - l]);\n        if (ret &gt;= MOD)\n            ret -= MOD;\n        return ret;\n    }\n\n  private:\n    template &lt;typename T&gt;\n    void _build(std::vector&lt;T&gt; &amp;a, long long base_ = -1) {\n        if (base_ == -1) {\n            RNG rng(base_);\n            base = rng.gen(1LL, 1LL &lt;&lt; 60);\n        } else {\n            base = base_;\n        }\n\n        N = a.size();\n        hs.resize(N + 1);\n        b.resize(N + 1);\n        b[0] = 1;\n        hs[0] = 0;\n        for (int i = 0; i &lt; N; i++) {\n            b[i + 1] = Mul(b[i], base);\n            hs[i + 1] = Mul(hs[i], base) + a[i];\n            if (hs[i + 1] &gt;= MOD)\n                hs[i + 1] -= MOD;\n        }\n    }\n\n    // mod 2^61-1\u3092\u8a08\u7b97\u3059\u308b\u95a2\u6570\n    long long CalcMod(long long x) {\n        long long xu = x &gt;&gt; 61;\n        long long xd = x &amp; MASK61;\n        long long ret = xu + xd;\n        if (ret &gt;= MOD)\n            ret -= MOD;\n        return ret;\n    }\n\n    // a*b mod 2^61-1\u3092\u8fd4\u3059\u95a2\u6570(\u6700\u5f8c\u306bMod\u3092\u53d6\u308b)\n    long long Mul(long long a, long long b) {\n        long long au = a &gt;&gt; 31;\n        long long ad = a &amp; MASK31;\n        long long bu = b &gt;&gt; 31;\n        long long bd = b &amp; MASK31;\n        long long mid = ad * bu + au * bd;\n        long long midu = mid &gt;&gt; 30;\n        long long midd = mid &amp; MASK30;\n        return CalcMod(au * bu * 2 + midu + (midd &lt;&lt; 31) + ad * bd);\n    }\n};\n</code></pre>"},{"location":"string/rolling_hash/#example","title":"Example","text":"<ul> <li>Codeforces Round 934 (Div. 1) B. Non-Palindromic Substring (C++)</li> </ul>"},{"location":"string/split/","title":"Split","text":""},{"location":"string/split/#c","title":"C++","text":"<pre><code>std::vector&lt;std::string&gt; split(const std::string &amp;str, char sep) {\n    std::vector&lt;string&gt; v;\n    std::stringstream ss(str);\n    std::string buffer;\n    while (std::getline(ss, buffer, sep)) {\n        v.push_back(buffer);\n    }\n    return v;\n}\n</code></pre>"},{"location":"string/z_algorithm/","title":"Z algorithm","text":""},{"location":"string/z_algorithm/#c","title":"C++","text":"<pre><code>template &lt;class T&gt;\nstd::vector&lt;int&gt; z_algorithm(std::vector&lt;T&gt; &amp;s) {\n    int c = 0, n = s.size();\n    std::vector&lt;int&gt; z(n, 0);\n    for (int i = 1; i &lt; n; i++) {\n        int l = i - c;\n        if (i + z[l] &lt; c + z[c]) {\n            z[i] = z[l];\n        } else {\n            int j = std::max(0, c + z[c] - i);\n            while (i + j &lt; n and s[j] == s[i + j])\n                j++;\n            z[i] = j;\n            c = i;\n        }\n    }\n    z[0] = n;\n    return z;\n}\n\nstd::vector&lt;int&gt; z_algorithm(std::string &amp;s) {\n    int n = s.size();\n    std::vector&lt;char&gt; v(n);\n    for (int i = 0; i &lt; n; i++)\n        v[i] = s[i];\n    return z_algorithm(v);\n}\n</code></pre>"},{"location":"string/z_algorithm/#example","title":"Example","text":"<ul> <li>ABC343 G - Compress Strings (C++)</li> </ul>"},{"location":"string/z_algorithm/#reference","title":"Reference","text":"<ul> <li>https://sen-comp.hatenablog.com/entry/2020/01/16/174230</li> </ul>"},{"location":"tree/auxiliary_tree/","title":"Auxiliary tree","text":""},{"location":"tree/auxiliary_tree/#c","title":"C++","text":"<pre><code>struct LowestCommonAncestor {\n    struct Edge {\n        int from, to, id;\n        Edge(int from, int to, int id = -1) : from(from), to(to), id(id) {}\n        Edge rev() {\n            return Edge(to, from, id);\n        }\n    };\n\n    LowestCommonAncestor() : LowestCommonAncestor(0) {}\n    LowestCommonAncestor(int N) : N(N) {\n        edges.resize(N);\n        depth.resize(N, 0);\n        LOGN = std::bit_width(uint32_t(N));\n        tab.resize(N, std::vector&lt;int&gt;(LOGN + 1, -1));\n    }\n\n    void add_edge(int from, int to, int id = -1) {\n        edges[from].emplace_back(from, to, id);\n    }\n\n    void build(int r = 0) {\n        std::queue&lt;std::pair&lt;int, int&gt;&gt; q;\n        q.emplace(r, r);\n        while (!q.empty()) {\n            auto &amp;[v, par] = q.front();\n            q.pop();\n            for (Edge &amp;e : edges[v]) {\n                if (e.to == par)\n                    continue;\n                depth[e.to] = depth[v] + 1;\n                q.emplace(e.to, v);\n            }\n        }\n\n        for (int i = 0; i &lt; N; i++) {\n            for (Edge &amp;e : edges[i]) {\n                if (depth[e.from] + 1 == depth[e.to])\n                    continue;\n                tab[e.from][0] = e.to;\n            }\n        }\n\n        for (int k = 0; k &lt; LOGN; k++)\n            for (int i = 0; i &lt; N; i++) {\n                if (tab[i][k] == -1)\n                    continue;\n                tab[i][k + 1] = tab[tab[i][k]][k];\n            }\n    }\n\n    int lca(int u, int v) {\n        if (depth[u] &lt; depth[v])\n            std::swap(u, v);\n        int k = depth[u] - depth[v];\n        for (int i = 0; i &lt;= LOGN; i++) {\n            if (((k &gt;&gt; i) &amp; 1) == 0)\n                continue;\n            u = tab[u][i];\n        }\n        if (u == v)\n            return u;\n\n        for (int i = LOGN; i &gt;= 0; i--) {\n            if (tab[u][i] != tab[v][i]) {\n                u = tab[u][i];\n                v = tab[v][i];\n            }\n        }\n        return tab[u][0];\n    }\n\n  private:\n    int N, LOGN = 1;\n    std::vector&lt;vector&lt;Edge&gt;&gt; edges;\n    std::vector&lt;int&gt; depth;\n    std::vector&lt;std::vector&lt;int&gt;&gt; tab;\n};\n\nstruct AuxiliaryTree {\n    AuxiliaryTree(std::vector&lt;int&gt; attributes) : attributes(attributes) {\n        N = attributes.size();\n        M = *std::max_element(attributes.begin(), attributes.end()) + 1;\n\n        lca = LowestCommonAncestor(N);\n        edges.resize(N);\n    }\n\n    void add_edge(int from, int to) {\n        lca.add_edge(from, to);\n        edges[from].emplace_back(from, to);\n    }\n\n    void build(int r = 0) {\n        preorder.resize(N, -1);\n        subtree_vertices.resize(M);\n\n        lca.build();\n        dfs(r);\n        build_trees();\n    }\n\n    int solve_tree(int tree_id) {\n        return trees[tree_id].solve();\n    }\n\n  private:\n    struct Edge {\n        int from, to, id;\n        Edge(int from, int to, int id = -1) : from(from), to(to), id(id) {}\n        Edge rev() {\n            return Edge(to, from, id);\n        }\n    };\n\n    struct Tree {\n        Tree() {}\n        Tree(std::vector&lt;int&gt; attributes) : attributes(attributes) {\n            N = attributes.size();\n            edges.resize(N);\n        }\n\n        void add_edge(int from, int to, int id = -1) {\n            edges[from].emplace_back(from, to, id);\n        }\n\n        int solve(int v = 0, int par = -1) {\n            if (N == 0)\n                return 0;\n            return 0;\n        }\n\n      private:\n        int N;\n        std::vector&lt;std::vector&lt;Edge&gt;&gt; edges;\n        std::vector&lt;int&gt; attributes;\n    };\n\n    int N, M;\n    std::vector&lt;int&gt; attributes, preorder;\n    std::vector&lt;std::vector&lt;int&gt;&gt; subtree_vertices;\n    std::vector&lt;std::vector&lt;Edge&gt;&gt; edges;\n    std::vector&lt;Tree&gt; trees;\n    LowestCommonAncestor lca;\n\n    void dfs(int r) {\n        int order = 0;\n        std::stack&lt;std::pair&lt;int, int&gt;&gt; stk;\n        stk.emplace(r, 0);\n\n        while (!stk.empty()) {\n            auto [v, pos] = stk.top();\n            stk.pop();\n\n            if (pos == 0) {\n                preorder[v] = order++;\n                subtree_vertices[attributes[v]].push_back(v);\n            }\n\n            for (int i = pos; i &lt; edges[v].size(); i++) {\n                Edge &amp;e = edges[v][i];\n                if (preorder[e.to] &gt; -1)\n                    continue;\n                stk.emplace(v, i + 1);\n                stk.emplace(e.to, 0);\n                break;\n            }\n        }\n    }\n\n    void build_trees() {\n        trees.resize(M);\n        std::vector&lt;int&gt; to_subtree_id(N, 0);\n\n        for (int i = 0; i &lt; M; i++) {\n            int n = subtree_vertices[i].size();\n\n            for (int j = 0; j &lt; n - 1; j++) {\n                int r = lca.lca(subtree_vertices[i][j], subtree_vertices[i][j + 1]);\n                if (attributes[r] != i)\n                    subtree_vertices[i].push_back(r);\n            }\n\n            std::sort(subtree_vertices[i].begin(),\n                      subtree_vertices[i].end(),\n                      [&amp;](int i, int j) { return preorder[i] &lt; preorder[j]; });\n            subtree_vertices[i].erase(\n                std::unique(subtree_vertices[i].begin(), subtree_vertices[i].end()),\n                subtree_vertices[i].end());\n\n            n = subtree_vertices[i].size();\n            for (int j = 0; j &lt; n; j++)\n                to_subtree_id[subtree_vertices[i][j]] = j;\n\n            std::vector&lt;int&gt; sub_attributes(n, 0);\n            for (int j = 0; j &lt; n; j++)\n                sub_attributes[j] = attributes[subtree_vertices[i][j]] == i;\n\n            Tree tree(sub_attributes);\n            for (int j = 0; j &lt; n - 1; j++) {\n                int r = lca.lca(subtree_vertices[i][j], subtree_vertices[i][j + 1]);\n                int from = to_subtree_id[r], to = to_subtree_id[subtree_vertices[i][j + 1]];\n\n                tree.add_edge(from, to);\n                tree.add_edge(to, from);\n            }\n            trees[i] = tree;\n        }\n    }\n};\n</code></pre>"},{"location":"tree/auxiliary_tree/#example","title":"Example","text":"<ul> <li>ABC340 G - Leaf Color (C++)</li> </ul>"},{"location":"tree/lowest_common_ancestor/","title":"Lowest common ancestor","text":""},{"location":"tree/lowest_common_ancestor/#c","title":"C++","text":"<pre><code>template&lt;class T=int&gt;\nstruct LCA {\n    struct Edge {\n        int from, to;\n        T cost;\n        int id;\n        Edge(int from, int to, T cost=1, int id=-1):from(from), to(to), cost(cost), id(id) {}\n        Edge rev(){\n            return Edge(to, from, cost, id);\n        }\n    };\n\n    int N, LOGN = 1;\n    std::vector&lt;vector&lt;Edge&gt;&gt; edges;\n    std::vector&lt;int&gt; depth;\n    std::vector&lt;std::vector&lt;int&gt;&gt; tab;\n\n    LCA(): LCA(0) {}\n    LCA(int N): N(N) {\n        edges.resize(N);\n        depth.resize(N,0);\n        while((1&lt;&lt;LOGN) &lt; N) LOGN++;\n        tab.resize(N,std::vector&lt;int&gt;(LOGN+1,-1));\n    }\n\n    void add_edge(int from, int to, T cost=1, int id=-1){\n        edges[from].emplace_back(from, to, cost, id);\n    }\n\n    void build(int r=0){\n        std::queue&lt;std::pair&lt;int,int&gt;&gt; q; q.emplace(r, r);\n        while(!q.empty()){\n            auto&amp; [v, par] = q.front(); q.pop();\n            for(Edge&amp; e : edges[v]){\n                if(e.to == par) continue;\n                depth[e.to] = depth[v] + 1;\n                q.emplace(e.to, v);\n            }\n        }\n\n        for(int i=0; i&lt;N; i++){\n            for(Edge&amp; e : edges[i]){\n                if(depth[e.from]+1 == depth[e.to]) continue;\n                tab[e.from][0] = e.to;\n            }\n        }\n\n        for(int k=0; k&lt;LOGN; k++)\n            for(int i=0; i&lt;N; i++){\n                if(tab[i][k] == -1) continue;\n                tab[i][k+1] = tab[tab[i][k]][k];\n            }\n    }\n\n    std::vector&lt;std::vector&lt;T&gt;&gt; build_tab2(const function&lt;T(T,T)&gt;&amp; merge, T id){\n        std::vector&lt;std::vector&lt;T&gt;&gt; tab2(N,std::vector&lt;T&gt;(LOGN+1,id));\n        for(int i=0; i&lt;N; i++)\n            for(Edge&amp; e : edges[i]){\n                if(depth[e.from]+1 == depth[e.to]) continue;\n                tab2[e.from][0] = e.cost;\n            }\n\n        for(int k=0; k&lt;LOGN; k++)\n            for(int i=0; i&lt;N; i++){\n                if(tab[i][k] == -1) continue;\n                tab2[i][k+1] = merge(tab2[i][k], tab2[tab[i][k]][k]);\n            }\n\n        return tab2;\n    }\n\n    int lca(int u, int v){\n        if(depth[u] &lt; depth[v]) swap(u,v);\n        int k = depth[u] - depth[v];\n        for(int i=0; i&lt;=LOGN; i++){\n            if(((k&gt;&gt;i)&amp;1) == 0) continue;\n            u = tab[u][i];\n        }\n        if(u == v) return u;\n\n        for(int i=LOGN; i&gt;=0; i--){\n            if(tab[u][i] != tab[v][i]){\n                u = tab[u][i];\n                v = tab[v][i];\n            }\n        }\n        return tab[u][0];\n    }\n\n    T lca_tab2(int u, int v, const function&lt;T(T,T)&gt;&amp; merge, T id, const std::vector&lt;std::vector&lt;T&gt;&gt;&amp; tab2){\n        // aggregation cost on path u-v\n        T ret = id;\n        if(depth[u] &lt; depth[v]) swap(u,v);\n        int k = depth[u] - depth[v];\n        for(int i=0; i&lt;=LOGN; i++){\n            if(((k&gt;&gt;i)&amp;1) == 0) continue;\n            ret = merge(ret, tab2[u][i]);\n            u = tab[u][i];\n        }\n        if(u == v) return ret;\n\n        for(int i=LOGN; i&gt;=0; i--){\n            if(tab[u][i] != tab[v][i]){\n                ret = merge(ret, tab2[u][i]);\n                ret = merge(ret, tab2[v][i]);\n                u = tab[u][i];\n                v = tab[v][i];\n            }\n        }\n        ret = merge(ret, tab2[u][0]);\n        ret = merge(ret, tab2[v][0]);\n        return ret;\n    }\n};\n</code></pre>"},{"location":"tree/rerooting/","title":"Rerooting","text":""},{"location":"tree/rerooting/#c","title":"C++","text":"<pre><code>template&lt;typename T&gt;\nstruct ReRooting{\n    typedef function&lt;T(T,T)&gt; F1;\n    typedef function&lt;T(T,int)&gt; F2;\n\n    struct Node{\n        int to, cost;\n        Node(int t, int c): to(t), cost(c) {}\n    };\n\n    int N;\n    F1 merge;\n    F2 addNode;\n    T e;\n    vector&lt;vector&lt;Node&gt;&gt; adj;\n\n    vector&lt;vector&lt;int&gt;&gt; i4adj;\n    vector&lt;vector&lt;T&gt;&gt; dp; // dp[i][j] := i\u3092\u89aa, j\u756a\u76ee\u306e\u96a3\u63a5\u30ce\u30fc\u30c9\u3092\u6839\u3068\u3059\u308b\u90e8\u5206\u6728\u306e\u5024\n    vector&lt;T&gt; ret;\n\n    ReRooting(int n, F1 f, F2 g, T identity): N(n), merge(f), addNode(g), e(identity){\n        i4adj.resize(n);\n        adj.resize(n);\n    }\n\n    void add_edge(int i, int j, int cost=1){\n        i4adj[i].push_back((int)adj[j].size());\n        i4adj[j].push_back((int)adj[i].size());\n        adj[i].emplace_back(Node(j, cost)); // i\u304b\u3089\u898b\u3066k\u756a\u76ee\u306e\u30ce\u30fc\u30c9\u306fj\n        adj[j].emplace_back(Node(i, cost)); // j\u304b\u3089\u898b\u3066l\u756a\u76ee\u306e\u30ce\u30fc\u30c9\u306fi\n    }\n\n    void initialize(){\n        dp.resize(N);\n        for(int i=0; i&lt;N; i++)\n            dp[i].resize(adj[i].size());\n        ret.resize(N);\n\n        if(N == 1){\n            ret[0] = addNode(e, 0);\n            return;\n        }\n\n        vector&lt;int&gt; par(N), order(N); // par[i] := 0\u3092\u6839\u3068\u3057\u305f\u3068\u304d\u306e\u89aa order[i] := dfs\u3067\u306ei\u756a\u76ee\u306e\u8a2a\u554f\u30ce\u30fc\u30c9\n        par[0] = -1;\n        int index = 0;\n        stack&lt;int&gt; stk; stk.push(0);\n        while(!stk.empty()){\n            int node = stk.top(); stk.pop();\n            order[index++] = node;\n\n            for(Node&amp; e : adj[node]){\n                if(e.to == par[node]) continue;\n                stk.push(e.to);\n                par[e.to] = node;\n            }\n        }\n\n        // 0\u3092\u6839\u3068\u3059\u308b\u6728\u306b\u3064\u3044\u3066\u89e3\u3092\u6c42\u3081\u308b\n        for(int i=N-1; i&gt;=1; i--){\n            int node = order[i];\n            int parent = par[node];\n\n            T result = e;\n            int parIndex = -1;\n            for(int j=0; j&lt;adj[node].size(); j++){\n                Node&amp; e = adj[node][j];\n                if(e.to == parent){\n                    parIndex = j;\n                    continue;\n                }\n                result = merge(result, dp[node][j]);\n            }\n            dp[parent][i4adj[node][parIndex]] = addNode(result, node);\n        }\n\n        // \u5168\u3066\u306e\u9802\u70b9\u306b\u3064\u3044\u3066\u89e3\u3092\u6c42\u3081\u308b\n        for(int i=0; i&lt;N; i++){\n            int node = order[i];\n            T accum = e;\n            vector&lt;T&gt; accumsFromTail(adj[node].size());\n            accumsFromTail[accumsFromTail.size() - 1] = e;\n\n            for (int j=accumsFromTail.size()-1; j &gt;= 1; j--)\n                    accumsFromTail[j - 1] = merge(dp[node][j], accumsFromTail[j]);\n\n            for (int j = 0; j &lt; accumsFromTail.size(); j++) {\n                dp[adj[node][j].to][i4adj[node][j]] = addNode(merge(accum, accumsFromTail[j]), node);\n                accum = merge(accum, dp[node][j]);\n            }\n            ret[node] = addNode(accum, node);\n        }\n    }\n\n    T query(int node){\n        return ret[node];\n    }\n\n};\n</code></pre>"}]}